"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5023],{20569:function(e,n,t){t.d(n,{Z:function(){return T}});var i=t(85893),r=t(67294),o=t(59791),a=t(15861),l=t(5616),s=t(93946),u=t(86886),d=t(67720),c=t(66242),p=t(13869),g=t(73772),m={tmp:{tmp:{len:0,title:[],code:[]}},android:{tmp:{len:0,title:[],code:[]},sdk:{len:1,title:["Before & After"],code:['// Before\n      android {\n        compileSdkVersion 32\n        defaultConfig {\n            applicationId "com.example.sonjunhyeok.myhome"\n            minSdkVersion 24\n            targetSdkVersion 32\n    \n            versionCode 1\n            versionName "1.0"\n            testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"\n        }\n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile(\'proguard-android.txt\'), \'proguard-rules.pro\'\n            }\n        }\n    }\n\n// After\nandroid {\n    compileSdkVersion 34\n    defaultConfig {\n        applicationId "com.example.sonjunhyeok.myhome"\n        minSdkVersion 33\n        targetSdkVersion 34\n\n        versionCode 2\n        versionName "2.0"\n        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(\'proguard-android.txt\'), \'proguard-rules.pro\'\n        }\n    }\n}']},broadcast:{len:1,title:["Before(Global Broadcast) & After(Local Broadcast)"],code:["// Before\nBroadcastReceiver broadcastReceiver;\nbroadcastReceiver = new BroadcastReceiverForMainActivity();\n\n// After\nLocalBroadcastManager.getInstance(this).registerReceiver(LightInfoBroadcast, filter);"]},retrofit2:{len:2,title:["Before(AsyncTask) & After(Retrofit2)"],code:['// Before\n        public class Network extends AsyncTask<String, Void, String> {\n        private HttpURLConnection httpURLConnection = null;\n        private OutputStream outputStream = null;\n        private String data = null;\n        private String link = "192.168.0.254/home";\n        private String line = null;\n        private String mJsonString = null;\n        private int responseStatusCode = 0;\n        private int mode = 0;\n        private boolean dialog_use = false;\n        private boolean upload_mode = false;\n    \n        private Context context;\n        private InputStream inputStream = null;\n        private InputStreamReader inputStreamReader = null;\n        private BufferedReader bufferedReader = null;\n        private StringBuilder stringBuilder = null;\n        private URL url = null;\n    \n        private ProgressDialog progressDialog;\n    \n        public Network(Context context){\n            this.context = context;\n            this.dialog_use = true;\n        }\n        public Network(){\n            this.dialog_use = false;\n        }\n        @Override\n        protected void onPreExecute() {\n            if(dialog_use) {\n                progressDialog = new ProgressDialog(context);\n                progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);\n                progressDialog.setCancelable(false);\n                progressDialog.setMessage("로딩 중입니다.");\n                progressDialog.show();\n            }\n            super.onPreExecute();\n        }\n    \n        @Override\n        protected String doInBackground(String... _param){\n            String n = _param[0];\n            switch (n){\n                case "login":\n                    link += "/Login_Check.php";\n                    Login_Input(_param[1],_param[2]);\n                    mode = 1;\n                    upload_mode = true;\n                    break;\n                /*.....*/\n    \n            }\n            try{\n                url = new URL(link);\n    \n                httpURLConnection = (HttpURLConnection)url.openConnection();\n                httpURLConnection.setReadTimeout(15000);\n                httpURLConnection.setConnectTimeout(15000);\n                httpURLConnection.setRequestMethod("POST");\n                httpURLConnection.setDoInput(true);\n                httpURLConnection.setDoOutput(true);\n                httpURLConnection.connect();\n    \n                if(upload_mode) {\n                    outputStream = httpURLConnection.getOutputStream();\n                    outputStream.write(data.getBytes(StandardCharsets.UTF_8));\n                    outputStream.flush();\n                    outputStream.close();\n                }\n    \n                responseStatusCode = httpURLConnection.getResponseCode();\n    \n                if(responseStatusCode == HttpURLConnection.HTTP_OK){\n                    inputStream = httpURLConnection.getInputStream();\n                    System.out.println("response is ok");\n                }\n                else{\n                    inputStream = httpURLConnection.getErrorStream();\n                }\n                inputStreamReader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);\n                bufferedReader = new BufferedReader(inputStreamReader);\n    \n                stringBuilder = new StringBuilder();\n    \n                while((line = bufferedReader.readLine()) != null){\n                    stringBuilder.append(line);\n                }\n    \n                httpURLConnection.disconnect();\n                return stringBuilder.toString().trim();\n    \n            } catch (ProtocolException e) {\n                e.printStackTrace();\n                System.out.println("protocol error");\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.out.println("IO error");\n            }\n    \n            return "Error";\n        }\n    \n        @Override\n        protected void onPostExecute(String s) {\n            switch (mode){\n                case 1://login\n                    break;\n                case 2:\n                    break;\n                case 3:\n                    break;\n            }\n            if(dialog_use) {\n                progressDialog.dismiss();\n            }\n            super.onPostExecute(s);\n        }\n    \n        private void Login_Input(String user_id, String user_pw){\n            try {\n                data = URLEncoder.encode("ID", "UTF-8") + "=" + URLEncoder.encode(user_id, "UTF-8");\n                data += "&" + URLEncoder.encode("PW", "UTF-8") + "=" + URLEncoder.encode(user_pw, "UTF-8");\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        private void Signin_Input(String user_id, String user_pw, String user_name){\n            try {\n                data = URLEncoder.encode("ID", "UTF-8") + "=" + URLEncoder.encode(user_id, "UTF-8");\n                data += "&" + URLEncoder.encode("Name","UTF-8")+"="+ URLEncoder.encode(user_name,"UTF-8");\n                data += "&" + URLEncoder.encode("PW", "UTF-8") + "=" + URLEncoder.encode(user_pw, "UTF-8");\n                System.out.println("Sign data : " + data);\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        /*.....*/\n    }\n\n    // After\n    public class LoadingAuthAdapter {\n        private final static String baseURL = BuildConfig.SERVER_ADDRESS;\n        private static int progressValue = 0;\n        private int MAINACTIVITY_CODE = 100;\n        private int LOGINACTIVITY_CODE = 200;\n    \n        private AuthService service;\n    \n        private Retrofit retrofit;\n    \n        public LoadingAuthAdapter(){\n            retrofit = new Retrofit.Builder()\n                    .baseUrl(baseURL)\n                    .addConverterFactory(ScalarsConverterFactory.create())\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build();\n            service = retrofit.create(AuthService.class);\n        }\n    \n        public void loginWithAuto(Context loadingActivityContext, SharedPreferences sp, String id, String pw, boolean weatherLoading, ProgressBar bar, TextView textView){\n            UserDto tmpDto = new UserDto(id, pw);\n            System.out.println("LoadingAuthAdapter AutoLoading tmpDto : " + tmpDto);\n    \n            new Thread(()->{\n                Call<String> callUserDto = service.signIn(tmpDto);\n                try {\n                    Response<String> callUserResponse = callUserDto.execute();\n                    if(callUserResponse.isSuccessful()){\n                        String callUserString = callUserResponse.body();\n                        Log.i("LoadingAuthAdapter","responsebody : " + callUserString);\n    \n                        JsonParser parser = new JsonParser();\n                        JsonElement element = parser.parse(callUserString);\n                        JsonObject object = element.getAsJsonObject();\n                        String strAccess = object.get("accessToken").getAsString();\n                        String strRefresh = object.get("refreshToken").getAsString();\n    \n    \n                        Intent intent = new Intent(loadingActivityContext, MainForceActivity.class);\n    \n                        USER user = bean.getUser();\n                        user.setAccessToken(strAccess);\n                        user.setRefreshToken(strRefresh);\n    \n                        Call<UserDto> callUserDTO = service.getUserInfo(strAccess);\n                        Response<UserDto> callUserResult = callUserDTO.execute();\n                        if(callUserResult.isSuccessful()){\n                            UserDto userDto = callUserResult.body();\n                            if(userDto != null){\n                                if(userDto.getName() != null) {\n                                    user.setName(userDto.getName());\n                                    if(userDto.getId() != null) user.setID(userDto.getId());\n    \n                                    boolean mustLoading = true;\n    \n                                    // light loading\n                                    changeTextView(textView, "IoT 서비스 로딩 중...");\n                                    MainLightAdapter lightAdapter = new MainLightAdapter();\n                                    boolean lightResult = lightAdapter.loadingLightItemsSync();\n                                    SharedPreferences sharedPreferences = loadingActivityContext.getSharedPreferences("roomMark",MODE_PRIVATE);\n                                    ArrayList<String> markRooms = markRoomJSONParsing(sharedPreferences);\n                                    bean.setMarkRoomList(markRooms);\n    \n                                    changeProgressBar(bar, ++progressValue);\n                                    if(lightResult){\n                                        changeTextView(textView, "IoT 서비스 로딩 완료");\n                                    }\n                                    else{\n                                        changeTextView(textView, "IoT 서비스 로딩 실패");\n                                        mustLoading = false;\n                                    }\n                                    Log.i("LoadingAuthAdapter", "light list size : "+bean.getLightListItems().size());\n    \n                                    if(weatherLoading) { // weather loading\n                                        changeTextView(textView, "날씨 로딩 중...");\n                                        MainWeatherAdapter weatherAdapter = new MainWeatherAdapter();\n                                        boolean weatherResult = weatherAdapter.setLoadingWeatherInfoSync(91,76);\n                                        changeProgressBar(bar, ++progressValue);\n                                        if(weatherResult){\n                                            changeTextView(textView, "날씨 로딩 완료");\n                                        }\n                                        else{\n                                            changeTextView(textView, "날씨 로딩 실패");\n                                        }\n                                    }\n                                    else{\n                                        changeProgressBar(bar, ++progressValue);\n                                    }\n                                    intent.putExtra("WeatherLoading", weatherLoading);\n    \n                                    // notice loading\n                                    changeTextView(textView, "공지 로딩 중...");\n                                    LoadingNoticeAdapter noticeAdapter = new LoadingNoticeAdapter();\n                                    boolean noticeResult = noticeAdapter.getNoticeListInfoSync();\n                                    if(noticeResult){\n                                        changeTextView(textView, "공지 로딩 완료");\n                                    }\n                                    else{\n                                        changeTextView(textView, "공지 로딩 실패");\n                                        mustLoading = false;\n                                    }\n                                    changeProgressBar(bar, ++progressValue);\n    \n    \n                                    // cloud loading\n                                    changeTextView(textView, "클라우드 로딩 중...");\n                                    CloudServiceAdapter cloudServiceAdapter = new CloudServiceAdapter();\n                                    boolean cloudResult = cloudServiceAdapter.getCloudDefaultPathSync();\n                                    if(cloudResult){\n                                        changeTextView(textView, "클라우드 로딩 완료");\n                                    }\n                                    else{\n                                        changeTextView(textView, "클라우드 로딩 실패");\n                                        mustLoading = false;\n                                    }\n                                    changeProgressBar(bar, ++progressValue);\n    \n    \n                                    if(mustLoading) ((LoadingActivity) loadingActivityContext).startLoading(intent);\n                                    else throw new IOException();\n    \n                                }\n    \n                            }\n                        }\n                        else{\n                            SharedPreferences.Editor autoLoginDelete = sp.edit();\n                            autoLoginDelete.clear();\n                            autoLoginDelete.apply();\n                            Intent loginIntent = new Intent(loadingActivityContext, LoginActivity.class);\n                            loginIntent.putExtra("factor","autoFailed");\n                            ((LoadingActivity) loadingActivityContext).startLoading(loginIntent);\n                        }\n                    }\n                    else{\n                        showToast(loadingActivityContext,"서버에서 오류가 발생했습니다.");\n                        SharedPreferences.Editor autoLoginDelete = sp.edit();\n                        autoLoginDelete.clear();\n                        autoLoginDelete.apply();\n                        Intent intent = new Intent(loadingActivityContext, LoginActivity.class);\n                        intent.putExtra("factor","autoFailed");\n                        ((LoadingActivity) loadingActivityContext).startLoading(intent);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    showToast(loadingActivityContext,"서버에서 오류가 발생했습니다.");\n                    SharedPreferences.Editor autoLoginDelete = sp.edit();\n                    autoLoginDelete.clear();\n                    autoLoginDelete.apply();\n                    Intent intent = new Intent(loadingActivityContext, LoginActivity.class);\n                    intent.putExtra("factor","autoFailed");\n                    ((LoadingActivity) loadingActivityContext).startLoading(intent);\n                }\n            }).start();\n        }\n        private ArrayList<String> markRoomJSONParsing(SharedPreferences sp){\n            String jsonStr = sp.getString("roomMark",null);\n            ArrayList<String> roomNames = new ArrayList<>();\n            if(jsonStr != null){\n                try {\n                    JSONArray jsonArray = new JSONArray(jsonStr);\n                    for(int i=0;i<jsonArray.length();i++){\n                        roomNames.add(jsonArray.optString(i));\n                    }\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n            return roomNames;\n        }\n        public void showToast(Context context, String msg){\n            Handler handler = new Handler(Looper.getMainLooper());\n            handler.post(() -> Toast.makeText(context, msg, Toast.LENGTH_LONG).show());\n        }\n        public void changeTextView(TextView textView, String content){\n            textView.post(() -> textView.setText(content));\n        }\n        public void changeProgressBar(ProgressBar bar, int progressValue){\n            bar.post(() -> bar.setProgress(progressValue));\n        }\n    }']},fragment:{len:0,title:[],code:[]},component:{len:0,title:[],code:[]},thumbnail:{len:0,title:[],code:[]},mvvm:{len:0,title:[],code:[]},defaultInfo:{len:2,title:["Before(HardCoding) & After(DB)"],code:['// Before\npath_private_trash_can = "/home/disk1/home/private/User_"+fnumber+"/휴지통";\npath_public_trash_can ="/home/disk1/home/public/휴지통";\nserver_folder_private.add("/home/disk1/home/private/User_"+fnumber);\nserver_folder_public.add("/home/disk1/home/public");\n        \n// After\nCloudServiceAdapter cloudServiceAdapter = new CloudServiceAdapter();\nboolean cloudResult = cloudServiceAdapter.getCloudDefaultPathSync();\nif(cloudResult){\n    changeTextView(textView, "클라우드 로딩 완료");\n}\nelse{\n    changeTextView(textView, "클라우드 로딩 실패");\n    mustLoading = false;\n}\n        ']},enum:{len:1,title:["Enum(MQTT part)"],code:['public enum MQTTEnum {\n        LIGHT("SEND_MQTT_LIGHT"),\n        NOTICE("SEND_MQTT_NOTICE"),\n        DISCONNECT("SEND_MQTT_DISCONNECT"),\n    \n        TOPIC_LIGHT_PUB("MyHome/Light/Pub/Server"),\n        TOPIC_LIGHT_SUB("MyHome/Light/Result"),\n        TOPIC_NOTICE_PUB(""),\n        TOPIC_NOTICE_SUB("MyHome/Notice/Sub");\n    \n        private final String target;\n        MQTTEnum(String target){this.target = target;}\n        public String getTarget(){return target;}\n    }']}},backend:{jwt:{len:1,title:["JWTProvider"],code:['@Configuration\n      public class JwtTokenProvider implements InitializingBean {\n          private String secretKey = "MyHomeProjectHS256AlgorithmPrivateSecretKey"; //must over 256 bit\n          private Key key;\n      \n          // 토큰 유효시간 30분\n          private final static long accessTokenValidTime = 10 * 3600 * 60 * 1000L; // 10일\n          private final static long refreshTokenValidTime = 20 * 3600 * 60 * 1000L; // 10일\n      \n          @Autowired\n          UserRepository userRepository;\n      \n          // 객체 초기화, secretKey를 Base64로 인코딩한다.\n          @PostConstruct\n          protected void init() {\n              secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());\n          }\n      \n          @Override\n          public void afterPropertiesSet() throws Exception {\n              byte[] keyBytes = Decoders.BASE64.decode(secretKey);\n              this.key = Keys.hmacShaKeyFor(keyBytes);\n          }\n          // JWT 토큰 생성\n          public String createToken(String userPk, String roles, boolean choice) {\n              Claims claims = Jwts.claims().setSubject(userPk); // JWT payload 에 저장되는 정보단위, 보통 여기서 user를 식별하는 값을 넣는다.\n              claims.put("roles", roles); // 정보는 key / value 쌍으로 저장된다.\n              Date now = new Date();\n              long validTime = 0;\n              if(choice){\n                  validTime = accessTokenValidTime;\n              }\n              else{\n                  validTime = refreshTokenValidTime;\n              }\n              return Jwts.builder()\n                      .setClaims(claims) // 정보 저장\n                      .setIssuedAt(now) // 토큰 발행 시간 정보\n                      .setExpiration(new Date(now.getTime() + validTime)) // set Expire Time\n                      .signWith(key, SignatureAlgorithm.HS256) // 사용할 암호화 알고리즘과\n                      .compact();\n          }\n      \n          // JWT 토큰에서 인증 정보 조회\n          public Authentication getAuthentication(String token) {\n              UserDetails userDetails = userRepository.findByAccessToken(token).orElseThrow(() -> new UsernameNotFoundException(token));\n              return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());\n          }\n      \n          // 토큰에서 회원 정보 추출\n          public String getUserPk(String token) {\n              return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody().getSubject();\n          }\n      \n          // Request의 Header에서 token 값을 가져옵니다. "Authorization" : "TOKEN값\'\n          public String resolveToken(HttpServletRequest request) {\n              return request.getHeader("Authorization");\n          }\n      \n          // 토큰의 유효성 + 만료일자 확인\n          public boolean validateToken(String jwtToken) {\n              try {\n      //            Jws<Claims> claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwtToken);\n      //            return !claims.getBody().getExpiration().before(new Date());\n                  Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jwtToken);\n                  return true;\n              } catch (Exception e) {\n                  return false;\n              }\n          }\n      }']},rule:{len:0,title:[],code:[]},jwtFilter:{len:1,title:["JWTCustomFilter"],code:['protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n    log.info("doFilterInternal request url : {}", request.getRequestURI());\n    String url = request.getRequestURI();\n    if(checkURLJWTList(url)){\n        String[] urlArr = url.split("/");\n        String token = urlArr[urlArr.length - 1];\n        if(jwtTokenProvider.validateToken(token)){\n            Authentication authentication = jwtTokenProvider.getAuthentication(token);\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n\n            filterChain.doFilter(request, response);\n        }\n        else{\n            log.info("doFilterInternal token validate result is false");\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }\n    else{\n        try{\n            // 헤더에서 JWT 를 받아옵니다.\n            String token = jwtTokenProvider.resolveToken(request);\n            if(token != null){\n                // 유효한 토큰인지 확인합니다.\n                if (jwtTokenProvider.validateToken(token)) {\n                    // 토큰이 유효하면 토큰으로부터 유저 정보를 받아옵니다.\n                    Authentication authentication = jwtTokenProvider.getAuthentication(token);\n                    // SecurityContext 에 Authentication 객체를 저장합니다.\n                    SecurityContextHolder.getContext().setAuthentication(authentication);\n\n                    filterChain.doFilter(request, response);\n                }\n                else {\n                    log.info("doFilterInternal token validate result is false");\n                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                }\n            }\n            else{\n                log.info("doFilterInternal token is null");\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            }\n        }\n        catch (Exception e){\n            log.info("doFilterInternal exception");\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            response.setContentType("application/json;charset=UTF-8");\n        }\n    }\n}']},whiteList:{len:1,title:["White-List Filter"],code:[' private static final String[] URL_JWT_LIST = {\n        "/file/downloadPublicMedia/",\n        "/file/downloadPublicImageLowQuality/",\n        "/file/streamingPublicVideo/",\n        "/file/downloadPrivateMedia/",\n        "/file/downloadPrivateImageLowQuality/",\n        "/file/streamingPrivateVideo/",\n        "/file/downloadThumbNail/",\n};\n\nprivate boolean checkURLJWTList(String url){\n  for(String list : URL_JWT_LIST){\n      if(url.contains(list)) return true;\n  }\n  return false;\n}\n\n// code in JWTCustomFilter - doFilterInternal\nif(checkURLJWTList(url)){\n  String[] urlArr = url.split("/");\n  String token = urlArr[urlArr.length - 1];\n  if(jwtTokenProvider.validateToken(token)){\n      Authentication authentication = jwtTokenProvider.getAuthentication(token);\n      SecurityContextHolder.getContext().setAuthentication(authentication);\n\n      filterChain.doFilter(request, response);\n  }\n  else{\n      log.info("doFilterInternal token validate result is false");\n      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n  }\n}\n']},customFilter:{len:1,title:["CustomFilter"],code:['public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n        @Autowired\n        private RequestMappingHandlerMapping requestMappingHandlerMapping;\n    \n        @Override\n        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n            int endPointResult = isEndPointExist(request);\n            if(endPointResult == 1){\n                response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            }\n            else if(endPointResult == -1){\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            }\n        }\n        private int isEndPointExist(HttpServletRequest request){\n            log.info("isEndPoint request url : {}", request.getRequestURI());\n            Map<RequestMappingInfo, HandlerMethod> map = requestMappingHandlerMapping.getHandlerMethods();\n            Set<RequestMappingInfo> requestMappingInfoSet = map.keySet();\n    \n            int result = -1; // 404\n    \n            for(RequestMappingInfo requestMappingInfo : requestMappingInfoSet){\n                Set<String> directPaths = requestMappingInfo.getDirectPaths();\n                if (!directPaths.isEmpty() && directPaths.contains(request.getRequestURI())) {\n                    Set<RequestMethod> methods = requestMappingInfo.getMethodsCondition().getMethods();\n                    if (!methods.isEmpty()) {\n                        if(!methods.contains(RequestMethod.valueOf(request.getMethod()))) result = 1; // 405\n                        else return 0; // 200\n                    }\n                }\n            }\n            return result;\n        }\n    }']},weatherFeature:{len:1,title:["Weather API list"],code:['\n      @Operation(description = "도시의 x, y 좌표를 이용하여 현재 날씨 데이터 얻는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "null 일 경우 백엔드 에러. 그 외 정상 처리 자세한 정보는 https://openweathermap.org/current 참조")\n      })\n      @GetMapping("/getCurrentInfoByCoordinate/{x}/{y}")\n      public ResponseEntity<OpenWeatherCurrentDto> getCurrentInfoByCoordinate(@PathVariable int x, @PathVariable int y){\n          OpenWeatherCurrentDto dto = weatherService.getCurrentWeatherInfoByCoordinate(x, y);\n          return new ResponseEntity<>(dto, HttpStatus.OK);\n      }\n  \n      @Operation(description = "도시의 x, y 좌표를 이용하여 5일간 3시간 데이터 얻는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "null 일 경우 백엔드 에러. 그 외 정상 처리 자세한 정보는 https://openweathermap.org/current 참조")\n      })\n      @GetMapping("/getForecastInfoByCoordinate/{x}/{y}")\n      public ResponseEntity<OpenWeatherForecastDto> getForecastInfoByCoordinate(@PathVariable int x, @PathVariable int y){\n          OpenWeatherForecastDto dto = weatherService.getForecastWeatherInfoByCoordinate(x, y);\n          return new ResponseEntity<>(dto, HttpStatus.OK);\n      }\n  \n      @Operation(description = "도시의 x, y 좌표를 이용하여 5일의 각각 날의 평균 데이터 얻는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "null 일 경우 백엔드 에러. 그 외 정상 처리 자세한 정보는 https://openweathermap.org/current 참조")\n      })\n      @GetMapping("/getForecastAverageInfoByCoordinate/{x}/{y}")\n      public ResponseEntity<List<ForecastDayDto>> get5DayAverageWeatherInfoByCoordinate(@PathVariable int x, @PathVariable int y){\n          List<ForecastDayDto> list = weatherService.get5DayAverageWeatherInfoByCoordinate(x, y);\n          return new ResponseEntity<>(list, HttpStatus.OK);\n      }']},iotFeature:{len:1,title:["IoT API"],code:['@PostMapping("/control/{accessToken}")\n      public ResponseEntity<String> control(@RequestBody LightDto dto, @PathVariable String accessToken){\n          String userPK = jwtTokenProvider.getUserPk(accessToken);\n          if(userPK == null) return new ResponseEntity<>("no data about token", HttpStatus.UNAUTHORIZED);\n  \n          Optional<UserEntity> entity = userService.findById(userPK);\n          if(entity.isEmpty()) return new ResponseEntity<>("no data in user pool", HttpStatus.FORBIDDEN);\n  \n          lightService.control(dto, entity.get().getName());\n          return new ResponseEntity<>(null, HttpStatus.OK);\n      }']},sftp:{len:1,title:["Cloud file control API List(Android)"],code:['    /*\n        * Common Part\n        * */\n    \n        @GET("/file/getDefaultPath")\n        Call<List<CloudDefaultPathDto>> getDefaultPath();\n    \n        /*\n        * Public Part\n        * */\n    \n        @GET("/file/getPublicFileInfo")\n        Call<CloudPublicDto> getPublicFileInfo(@Query("path") String path);\n    \n        @GET("/file/getPublicFileListInfo")\n        Call<List<CloudPublicDto>> getPublicFileListInfo(@Query("location") String location);\n    \n        @GET("/file/getPublicFileListInfoPage")\n        Call<List<CloudPublicDto>> getPublicFileListInfoPage(@Query("location") String location, @Query("size") int size, @Query("page") int page);\n    \n        @GET("/file/movePublicFileInfo")\n        Call<Integer> movePublicFileInfo(@Query("path") String path, @Query("location") String location);\n    \n        @POST("/file/downloadPublicFile")\n        @Streaming\n        Call<ResponseBody> downloadPublicFile(@Body CloudPublicDto dto);\n    \n        @GET("/file/downloadPublicMedia/{uuid}/{accessToken}")\n        @Streaming\n        Call<ResponseBody> downloadPublicFileMedia(@Path("uuid") String uuid, @Path("accessToken") String accessToken);\n    \n        @GET("/file/downloadPublicImageLowQuality/{uuid}/{accessToken}")\n        @Streaming\n        Call<ResponseBody> downloadPublicImageFileLowQuality(@Path("uuid") String uuid, @Path("accessToken") String accessToken);\n    \n        @GET("/file/getPublicTrashFiles")\n        Call<List<CloudPublicDto>> getPublicTrashFiles(@Query("location") String location);\n    \n        @POST("/file/uploadPublicFile")\n        Call<List<String>> uploadPublicFile(@Query("uploadFile")Multipart multipart, @Query("path") String path);\n    \n    ']},fullSearch:{len:1,title:["Scheduler"],code:['@Scheduled(cron = "0 0 0 * * *") // top of e every day\n      public void checkCloudFile() {\n          logComponent.sendLog("cloud-Check", "[checkCloudFile(Reserve)] check start", true, TOPIC_CLOUD_CHECK_LOG);\n          Date date = new Date();\n          try {\n              JobParameters publicJobParameters = new JobParametersBuilder()\n                      .addString("publicCheck-" + date.getTime(), String.valueOf(System.currentTimeMillis()))\n                      .toJobParameters();\n  \n              jobLauncher.run(publicCloudCheckJob, publicJobParameters);\n              fileServerPublicService.publicFileTrashStateCheck();\n          }\n          catch (Exception e){\n              logComponent.sendErrorLog("Cloud-Check", "[checkCloudFile(private)] error : ", e, TOPIC_CLOUD_CHECK_LOG);\n          }\n          try {\n              JobParameters privateJobParameters = new JobParametersBuilder()\n                      .addString("privateCheck-" + date.getTime(), String.valueOf(System.currentTimeMillis()))\n                      .toJobParameters();\n              jobLauncher.run(privateCloudCheckJob, privateJobParameters);\n              fileServerPrivateService.privateFileTrashCheck();\n          }\n          catch (Exception e){\n              logComponent.sendErrorLog("Cloud-Check", "[checkCloudFile(private)] error : ", e, TOPIC_CLOUD_CHECK_LOG);\n          }\n      }']},thumbnail:{len:1,title:["Thumbnail control API List"],code:['@Operation(description = "썸네일 다운로드 받는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 다운로드 혹은 파일이 없음"),\n              @ApiResponse(responseCode = "500", description = "백엔드 에러")\n      })\n      @GetMapping("/downloadThumbNail/{uuid}/{accessToken}")\n      public ResponseEntity<Resource> downloadThumbNail(@PathVariable String uuid, @PathVariable String accessToken){\n          return commonService.downloadThumbNail(uuid);\n      }\n  \n      @Operation(description = "썸네일 파일 존재하는지 확인하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리. true : 존재, false : 없음")\n      })\n      @GetMapping("/checkThumbNailFile/{uuid}")\n      public ResponseEntity<Boolean> checkThumbNailFileExist(@PathVariable String uuid){\n          boolean result = thumbNailService.checkThumbNailExist(uuid);\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }']},lowQualityImage:{len:2,title:["Low quality image feature(Public)","Low quality thumbnail image feature"],code:['@Override\n      public ResponseEntity<Resource> downloadPublicImageLowQuality(String uuid) {\n          FileServerPublicEntity entity = fileServerRepository.findByUuid(uuid);\n          if(entity != null){\n              String pathStr = commonService.changeUnderBarToSeparator(entity.getPath());\n              try{\n                  File imageFile = new File(pathStr);\n  \n                  String tmpFileName = "tmpImageName"+System.currentTimeMillis();\n                  File outPutFile = new File(commonService.changeUnderBarToSeparator(thumbnailPath)+File.separator+tmpFileName);\n                  OutputStream os = new FileOutputStream(outPutFile);\n  \n                  float quality = 0.2f;\n  \n                  BufferedImage bufferedImage = ImageIO.read(imageFile);\n                  Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpg");\n                  if(!writers.hasNext()){\n                      logComponent.sendLog("Cloud","downloadPublicMediaLowQuality error : doesn\'t support format", false, TOPIC_CLOUD_LOG);\n                      return new ResponseEntity<>(commonService.getDefaultImageIconFile(), HttpStatus.OK);\n                  }\n                  else{\n                      ImageWriter imageWriter = writers.next();\n                      ImageOutputStream imageOutputStream = ImageIO.createImageOutputStream(os);\n                      imageWriter.setOutput(imageOutputStream);\n  \n                      ImageWriteParam param = imageWriter.getDefaultWriteParam();\n                      param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n                      param.setCompressionQuality(quality);\n                      imageWriter.write(null, new IIOImage(bufferedImage, null, null), param);\n                      os.close();\n                      imageOutputStream.close();\n                      imageWriter.dispose();\n  \n                      Path outPutPath = outPutFile.toPath();\n                      HttpHeaders httpHeaders = getHttpHeader(outPutPath, entity.getName());\n                      Resource resource = new InputStreamResource(Files.newInputStream(outPutPath)); // save file resource\n                      outPutFile.delete();\n                      return new ResponseEntity<>(resource, httpHeaders, HttpStatus.OK);\n                  }\n              } catch (IOException e) {\n                  logComponent.sendErrorLog("Cloud","downloadPublicMediaLowQuality error : ", e, TOPIC_CLOUD_LOG);\n                  return new ResponseEntity<>(commonService.getDefaultImageIconFile(), HttpStatus.OK);\n              }\n          }\n          else {\n              logComponent.sendLog("Cloud", "downloadPublicMediaLowQuality error : file doesn\'t exist", false, TOPIC_CLOUD_LOG);\n              return new ResponseEntity<>(commonService.getDefaultImageIconFile(), HttpStatus.OK);\n          }\n      }','@Transactional\n      @Override\n      public boolean makeThumbNail(File file, String uuid, String type) {\n          File thumbnail = new File(uploadPath, uuid+".jpg");\n          try{\n              FrameGrab frameGrab = FrameGrab.createFrameGrab(NIOUtils.readableChannel(file));\n  \n              // 첫 프레임의 데이터\n              frameGrab.seekToSecondPrecise(1);\n  \n              Picture picture = frameGrab.getNativeFrame();\n  \n              // 썸네일 파일에 복사\n              BufferedImage bi = AWTUtil.toBufferedImage(picture);\n              Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpg");\n              if(!writers.hasNext()) {\n                  ImageIO.write(bi, "jpg", thumbnail);\n              }\n              else{\n                  OutputStream os = new FileOutputStream(thumbnail);\n  \n                  float quality = 0.2f;\n  \n                  ImageWriter imageWriter = writers.next();\n                  ImageOutputStream imageOutputStream = ImageIO.createImageOutputStream(os);\n                  imageWriter.setOutput(imageOutputStream);\n  \n                  ImageWriteParam param = imageWriter.getDefaultWriteParam();\n                  param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);\n                  param.setCompressionQuality(quality);\n                  imageWriter.write(null, new IIOImage(bi, null, null), param);\n                  os.close();\n                  imageOutputStream.close();\n                  imageWriter.dispose();\n              }\n  \n          } catch (Exception e) {\n              if(thumbnail.exists()) {\n                  thumbnail.delete();\n              }\n              logComponent.sendErrorLog("Cloud-Check", "makeThumbNail Error : ", e, TOPIC_CLOUD_LOG);\n              return false;\n          }\n          return true;\n      }']},walksAndBulk:{len:1,title:["Full Search use walks(Public)"],code:['@Override\n      public List<File> filesWalkWithReturnMediaFileList() {\n          Path originPath = Paths.get(diskPath);\n          List<Path> pathList;\n          try{\n              Stream<Path> pathStream = Files.walk(originPath);\n              pathList = pathStream.collect(Collectors.toList());\n              List<FileServerPublicDto> fileList = new ArrayList<>();\n              List<File> mediaFileList = new ArrayList<>();\n              for(Path path : pathList){\n                  File file = new File(path.toString());\n                  String extension = "dir";\n                  if(!file.isDirectory()) {\n                      extension = file.getName().substring(file.getName().lastIndexOf(".") + 1); // file type (need to check ex: txt file -> text/plan)\n                  }\n                  try {\n                      String tmpPath = commonService.changeSeparatorToUnderBar(file.getPath());\n                      StringBuilder sb = new StringBuilder();\n                      String[] tmpPathArr = tmpPath.split("__");\n                      for(int i=0;i<tmpPathArr.length-1;i++){\n                          sb.append(tmpPathArr[i]).append("__");\n                      }\n                      String tmpLocation = sb.toString();\n  \n                      String uuid = UUID.nameUUIDFromBytes(tmpPath.getBytes(StandardCharsets.UTF_8)).toString();\n                      fileList.add(new FileServerPublicDto(\n                              tmpPath,\n                              file.getName(),\n                              uuid,\n                              extension,\n                              (float) (file.length() / 1024),\n                              tmpLocation,\n                              1,\n                              0\n                      ));\n                      if (Arrays.asList(videoExtensionList).contains(extension) && !thumbNailRepository.existsByUuid(uuid)) {\n                          mediaFileList.add(file);\n                      }\n                  }\n                  catch(Exception e){\n                      System.out.println(e.getMessage());\n                  }\n              }\n              fileServerCustomRepository.saveBatchPublic(fileList);\n              return mediaFileList;\n          }\n          catch (Exception e){\n              logComponent.sendErrorLog("Cloud-Check", "[filesWalk(public)] file check error : ", e, TOPIC_CLOUD_CHECK_LOG);\n          }\n          return null;\n      }']},batch:{len:1,title:["Batch by Multi-thread(Public)"],code:['@Bean\n      public Flow publicCloudSplitFlow(JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          FileDefaultPathEntity entity = defaultPathRepository.findByPathName("thumbnail");\n          uploadPath = commonService.changeUnderBarToSeparator(entity.getPublicDefaultPath());\n  \n          return new FlowBuilder<SimpleFlow>("PublicCloudSplitFlow-" + dateTime)\n                  .split(new SimpleAsyncTaskExecutor())\n                  .add(\n                          publicCloudFlow1(BatchEnum.CLOUD_PRIVATE_PARALLEL_FLOW_NAME.getPublicParallelFlowName(1), jobRepository, platformTransactionManager),\n                          publicCloudFlow2(BatchEnum.CLOUD_PRIVATE_PARALLEL_FLOW_NAME.getPublicParallelFlowName(2), jobRepository, platformTransactionManager),\n                          publicCloudFlow3(BatchEnum.CLOUD_PRIVATE_PARALLEL_FLOW_NAME.getPublicParallelFlowName(3), jobRepository, platformTransactionManager)\n                  )\n                  .build();\n      }\n  \n      @Bean\n      public Flow publicCloudFlow1(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new FlowBuilder<SimpleFlow>(name)\n                  .start(publicCloudParallelStep1(name, jobRepository, platformTransactionManager))\n                  .build();\n      }\n  \n      @Bean\n      public Step publicCloudParallelStep1(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new StepBuilder(name, jobRepository)\n                  .tasklet(((contribution, chunkContext) -> {\n                      int partitionSize = chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().getInt(BatchEnum.CLOUD_PUBLIC_CHUNK_PARTITION_NAME.getTarget());\n                      Pageable pageable = PageRequest.of(0, partitionSize);\n                      List<FileServerVideoEntity> videoEntityList = videoRepository.findAllBy(pageable);\n                      List<FileInfoDto> fileList = new ArrayList<>();\n                      for(FileServerVideoEntity entity : videoEntityList){\n                          FileInfoDto tmpDto = new FileInfoDto();\n                          tmpDto.setName(entity.getName());\n                          tmpDto.setUuid(entity.getUuid());\n                          tmpDto.setPath(entity.getPath());\n                          fileList.add(tmpDto);\n                      }\n  \n                      if(!fileList.isEmpty()){\n                          thumbNailSequence(fileList, uploadPath);\n                      }\n                      else{\n                          contribution.setExitStatus(ExitStatus.FAILED);\n                      }\n                      return RepeatStatus.FINISHED;            \n                  }), platformTransactionManager)\n                  .build();\n      }\n  \n      @Bean\n      public Flow publicCloudFlow2(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new FlowBuilder<SimpleFlow>(name)\n                  .start(publicCloudParallelStep2(name, jobRepository, platformTransactionManager))\n                  .build();\n      }\n  \n      @Bean\n      public Step publicCloudParallelStep2(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new StepBuilder(name, jobRepository)\n                  .tasklet(((contribution, chunkContext) -> {\n                      int partitionSize = chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().getInt(BatchEnum.CLOUD_PUBLIC_CHUNK_PARTITION_NAME.getTarget());\n                      Pageable pageable = PageRequest.of(1, partitionSize);\n                      List<FileServerVideoEntity> videoEntityList = videoRepository.findAllBy(pageable);\n                      List<FileInfoDto> fileList = new ArrayList<>();\n                      for(FileServerVideoEntity entity : videoEntityList){\n                          FileInfoDto tmpDto = new FileInfoDto();\n                          tmpDto.setName(entity.getName());\n                          tmpDto.setUuid(entity.getUuid());\n                          tmpDto.setPath(entity.getPath());\n                          fileList.add(tmpDto);\n                      }\n  \n                      if(!fileList.isEmpty()){\n                          thumbNailSequence(fileList, uploadPath);\n                      }\n                      else{\n                          contribution.setExitStatus(ExitStatus.FAILED);\n                      }\n                      return RepeatStatus.FINISHED;            \n                  }), platformTransactionManager)\n                  .build();\n      }\n  \n      @Bean\n      public Flow publicCloudFlow3(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new FlowBuilder<SimpleFlow>(name)\n                  .start(publicCloudParallelStep3(name, jobRepository, platformTransactionManager))\n                  .build();\n      }\n  \n      @Bean\n      public Step publicCloudParallelStep3(String name, JobRepository jobRepository, PlatformTransactionManager platformTransactionManager){\n          return new StepBuilder(name, jobRepository)\n                  .tasklet(((contribution, chunkContext) -> {\n                      int partitionSize = chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().getInt(BatchEnum.CLOUD_PUBLIC_CHUNK_PARTITION_NAME.getTarget());\n                      Pageable pageable = PageRequest.of(2, partitionSize);\n                      List<FileServerVideoEntity> videoEntityList = videoRepository.findAllBy(pageable);\n                      List<FileInfoDto> fileList = new ArrayList<>();\n                      for(FileServerVideoEntity entity : videoEntityList){\n                          FileInfoDto tmpDto = new FileInfoDto();\n                          tmpDto.setName(entity.getName());\n                          tmpDto.setUuid(entity.getUuid());\n                          tmpDto.setPath(entity.getPath());\n                          fileList.add(tmpDto);\n                      }\n  \n                      if(!fileList.isEmpty()){\n                          thumbNailSequence(fileList, uploadPath);\n                      }\n                      else{\n                          contribution.setExitStatus(ExitStatus.FAILED);\n                      }\n                      return RepeatStatus.FINISHED;            \n                  }), platformTransactionManager)\n                  .build();\n      }']},CIAndCD:{len:0,title:[],code:[]},restart:{len:0,title:[],code:[]},container:{len:0,title:[],code:[]},weatherMaintenance:{len:1,title:["Structure for maintenance about weather feature"],code:['@Autowired\n      public WeatherServiceImpl(WeatherAPIKeyRepository weatherAPIKeyRepository){\n          OPENWEATHERAPI_KEY = weatherAPIKeyRepository.findByServiceName("OpenWeatherAPI").getKey();\n          SGIS_SERVICE_KEY = weatherAPIKeyRepository.findByServiceName("SGISServiceKey").getKey();\n          SGIS_SECURITY_KEY = weatherAPIKeyRepository.findByServiceName("SGISSecurityKey").getKey();\n  \n          // Thunderstorm, Drizzle, Rain, Snow, Atmosphere, Clear, Clouds\n          openWeatherAPIWeatherHash = new HashMap<>();\n          openWeatherAPIWeatherHash.put(0, "Clear");\n          openWeatherAPIWeatherHash.put(1, "Clouds");\n          openWeatherAPIWeatherHash.put(2, "Atmosphere");\n          openWeatherAPIWeatherHash.put(3, "Rain");\n          openWeatherAPIWeatherHash.put(4, "Snow");\n          openWeatherAPIWeatherHash.put(5, "Drizzle");\n          openWeatherAPIWeatherHash.put(6, "Thunderstorm");\n      }']},cloud:{len:1,title:["Cloud file control API List(Public)"],code:['@Operation(description = "Public 파일을 원하는 폴더로 이동하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "리턴 값이 0이면 정상 처리")\n      })\n      @GetMapping("/movePublicFileInfo")\n      public ResponseEntity<Integer> movePublicFileInfo(@RequestParam(value="path") String path, @RequestParam(value="location") String location){\n          int result = service.moveFile(path, location);\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 파일 다운로드 받는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리")\n      })\n      @PostMapping("/downloadPublicFile")\n      public ResponseEntity<Resource> downloadPublicFile(@RequestBody FileServerPublicDto dto){\n          System.out.println("downloadPublicFile dto : "+dto.toString());\n          return service.downloadFile(dto.getUuid());\n      }\n  \n      @Operation(description = "Public 파일 중 미디어(영상 등) 파일 다운로드 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리"),\n              @ApiResponse(responseCode = "401", description = "권한 에러")\n      })\n      @CrossOrigin(origins = "*")\n      @GetMapping("/downloadPublicMedia/{uuid}/{accessToken}")\n      public ResponseEntity<Resource> downloadPublicMedia(@PathVariable String uuid, @PathVariable String accessToken){\n          return service.downloadPublicMedia(uuid);\n      }\n  \n      @Operation(description = "Public 파일 중 이미지 파일을 낮은 퀄리티로 다운로드 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리"),\n              @ApiResponse(responseCode = "401", description = "권한 에러")\n      })\n      @CrossOrigin(origins = "*")\n      @GetMapping("/downloadPublicImageLowQuality/{uuid}/{accessToken}")\n      public ResponseEntity<Resource> downloadPublicImageLowQuality(@PathVariable String uuid, @PathVariable String accessToken){\n          return service.downloadPublicImageLowQuality(uuid);\n      }\n  \n      @Operation(description = "Public 파일 중 미디어(영상) 파일 스트리밍 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리"),\n              @ApiResponse(responseCode = "401", description = "권한 에러")\n      })\n      @CrossOrigin(origins = "*")\n      @GetMapping("/streamingPublicVideo/{uuid}/{accessToken}")\n      public ResponseEntity<ResourceRegion> streamingPublicVideo(@RequestHeader HttpHeaders httpHeaders, @PathVariable String uuid, @PathVariable String accessToken){\n          return service.streamingPublicVideo(httpHeaders, uuid);\n      }\n  \n      @Operation(description = "Public 휴지통 파일 목록 중 원하는 폴더 기준으로 다 받아 오는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리")\n      })\n      @GetMapping("/getPublicTrashFileListInfo")\n      public ResponseEntity<List<FileServerPublicTrashEntity>> getPublicTrashFileListInfo(@RequestParam String location){\n          List<FileServerPublicTrashEntity> list = service.findByLocationTrash(location);\n          return new ResponseEntity<>(list, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 휴지통 파일 목록 중 원하는 폴더에 원하는 갯수, 페이지로 받아오는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리")\n      })\n      @GetMapping("/getPublicTrashFileListInfoPage")\n      public ResponseEntity<List<FileServerPublicTrashEntity>> getPublicTrashFileListInfoPage(@RequestParam String location, @RequestParam int size, @RequestParam int page){\n          List<FileServerPublicTrashEntity> list = service.findByLocationPageTrash(location,  size, page);\n          return new ResponseEntity<>(list, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 에 파일 업로드 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리")\n      })\n      @PostMapping("/uploadPublicFile") // upload files\n      public ResponseEntity<List<String>> uploadPublicFile(@RequestParam MultipartFile[] uploadFile, @RequestParam String path, Model model)\n      {\n          System.out.println("uploadPublicFile : " + path);\n          List<String> resultArr = service.uploadFiles(uploadFile, path, model);\n          return new ResponseEntity<>(resultArr, HttpStatus.OK); // return filename that success to insert file name in DB\n      }\n  \n      @Operation(description = "Public 에 원하는 위치에 폴더 생성하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "정상 처리"),\n              @ApiResponse(responseCode = "500", description = "서버 에러")\n      })\n      @PostMapping("/mkdirPublic")\n      public ResponseEntity<Void> mkdirPublic(@RequestParam String path){\n          if(service.mkdir(path)){\n              return new ResponseEntity<>(null, HttpStatus.OK);\n          }\n          else{\n              return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);\n          }\n      }\n  \n      @Operation(description = "Public 파일 정보 업데이트 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "결과 값이 0이면 정상 처리")\n      })\n      @PutMapping("/updatePublicFileInfo")\n      public ResponseEntity<Integer> updatePublicFileInfo(@RequestBody FileServerPublicDto dto){\n          int result = service.updateByFileServerPublicEntity(new FileServerPublicEntity(dto));\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 파일 중 휴지통에 있던 파일을 복원 하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "결과 값이 0이면 정상 처리")\n      })\n      @PutMapping("/restorePublicFile")\n      public ResponseEntity<Integer> restorePublic(@RequestParam String uuid){\n          int result = service.restore(uuid);\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 파일 중 휴지통으로 임시 삭제하는 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "결과 값이 0이면 정상 처리")\n      })\n      @DeleteMapping("/deletePublicFileToTrash")\n      public ResponseEntity<Long> deletePublicFileTrash(@RequestParam String uuid){\n          long result = service.moveTrash(uuid);\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }\n  \n      @Operation(description = "Public 휴지통에 있는 파일 완전 삭제 API")\n      @ApiResponses(value = {\n              @ApiResponse(responseCode = "200", description = "결과 값이 0이면 정상 처리")\n      })\n      @DeleteMapping("/deletePublicFileInfo/{path}")\n      public ResponseEntity<Long> deletePublicFileInfo(@PathVariable String path){\n          long result = service.deleteByPath(path); // delete file\n          return new ResponseEntity<>(result, HttpStatus.OK);\n      }']},onlyLogic:{len:1,title:["ORM code(example)"],code:["from django.db import models\n\n\n      # Create your models here.\n      \n      \n      class RoomLight(models.Model):\n          LIGHT_ROOM_PK = models.CharField(max_length=20, primary_key=True)\n          STATE_CHAR = models.CharField(max_length=10)\n          ROOMKOR_CHAR = models.CharField(max_length=20)\n          CATEGORY_CHAR = models.CharField(max_length=100)\n          CONNECT_CHAR = models.CharField(max_length=25)\n      \n          class Meta:\n              managed = False\n              db_table = 'LIGHT_ROOM_TB'"]},migration:{len:0,title:[],code:[]},buildLogSystem:{len:0,title:[],code:[]},logDivPart:{len:0,title:[],code:[]},block:{len:0,title:[],code:[]},enum:{len:3,title:["sample","Server","Android"],code:["public enum Sample{\n      TARGET\n}",'@Getter\n      public enum BatchEnum {\n          CLOUD_PUBLIC_CHUNK_PARTITION_NAME("PublicCloudPartition"),\n          CLOUD_PUBLIC_PARALLEL_FLOW_NAME("PublicCloudFlow-"),\n          CLOUD_PRIVATE_CHUNK_PARTITION_NAME("PrivateCloudPartition"),\n          CLOUD_PRIVATE_PARALLEL_FLOW_NAME("PrivateCloudFlow-");\n      \n          private final String target;\n          BatchEnum(String target){\n              this.target = target;\n          }\n          public String getPublicParallelFlowName(int num){\n              return CLOUD_PUBLIC_PARALLEL_FLOW_NAME+String.valueOf(num);\n          }\n          public String getPrivateParallelFlowName(int num){\n              return CLOUD_PRIVATE_PARALLEL_FLOW_NAME+String.valueOf(num);\n          }\n      }','public enum RoomInfoEnum {\n        BALCONY_MAIN("balcony main","balcony"),\n        BALCONY_SUB("balcony sub","balcony"),\n        BATHROOM_MAIN("bathRoom1","bath Room"),\n        BATHROOM_SUB("bathRoom2","bath Room"),\n        BIG_ROOM_TOP("big Room1","Big Room"),\n        BIG_ROOM_BOTTOM("big Room2","Big Room"),\n        KITCHEN_SINK("kitchen sink","kitchen"),\n        KITCHEN_TABLE("kitchen table","kitchen"),\n        LIVING_ROOM_TOP("living Room1","living Room"),\n        LIVING_ROOM_MIDDLE("living Room2","living Room"),\n        LIVING_ROOM_BOTTOM("living Room3","living Room"),\n        LIVING_ROOM_SUB("living Room sub","living Room"),\n        MIDDLE_ROOM_TOP("middle Room1","middle Room"),\n        MIDDLE_ROOM_BOTTOM("middle Room2","middle Room"),\n        SMALL_ROOM("small Room","small Room");\n    \n        private final String name;\n        private final String category;\n        RoomInfoEnum(String name, String category){\n            this.name = name;\n            this.category = category;\n        }\n    \n        public String getName() {\n            return name;\n        }\n    \n        public String getCategory() {\n            return category;\n        }\n        public static String getCategoryByName(String name){\n            for(RoomInfoEnum room : values()){\n                if(room.getName().equals(name))return room.getCategory();\n            }\n            return "no data";\n        }\n        public static String getNameByCategory(String category){\n            for(RoomInfoEnum room : values()){\n                if(room.getCategory().equals(category)) return room.getName();\n            }\n            return "no data";\n        }\n    }']}},iot:{tmp:{len:0,title:[],code:[]},origin:{len:1,title:["Ver 1. Full Code"],code:['#include <Ticker.h>\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include <ESP8266WebServer.h>\n#include <ESP8266mDNS.h>\n#include <ESP8266HTTPUpdateServer.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n\n#define APSSID          "wifi_id"   //AP SSID\n#define APPASSWORD      "wifi_password"         //AP password\n#define SERVERPORT      80         //Web server port\n#define WWWUSERNAME     "admin"    // Set www user name\n#define WWWPASSWORD     "admin"    // Set www user password\n#define OTAUSER         "otaAdmin"    // Set OTA user\n#define OTAPASSWORD     "otaAdmin"   // Set OTA password\n#define OTAPATH         "/firmware"// Set path for update\n#define RELAYPIN        15         // GPIO12 relay pin -> GPIO15\n#define LEDPIN          16         // GPIO13 GREEN LED (active low)-> GPIO16 change to wifi connect\n#define BUTTONPIN       5          // GPIO0 button pin -> GPIO5\n#define BUTTONTIME      0.05       // [s] time between button read\n#define BUTTONON        "color: green; border: 3px #fff outset;"\n#define BUTTONOFF       "color: red; border: 3px #fff outset;"\n#define BUTTONNOACT     "color: black; border: 7px #fff outset;"\n#define BUTTONDEBOUNCE  1 //Minimum number of seconds between a valid button press or relay switch.\n#define mqtt_server     "192.168.0.1"\n#define mqtt_port       1883\n#define mqtt_id         "test Room"\n#define mqtt_topic      "MyHome/Light/Sub/Server"\n#define mqtt_topic_sta  "MyHome/Light/Sub/Server/State"\n#define mqtt_topic_con  "MyHome/Light/Sub/Server/Connect"\n#define mqtt_topic_sub  "MyHome/Light/Pub/small Room"\n\nbool    LEDState        = true;    // Green LED off\nbool    RelayState      = false;   // Relay off\nbool    ButtonFlag      = false;   // Does the button need to be handled on this loop\nchar    ButtonCount     = 0;       // How many cycles/checks the button has been pressed for.\nString  OnButt;\nString  OffButt;\n\n//Setup classes needed from libraries.\nMDNSResponder mdns;\nTicker buttonTick;\nESP8266WebServer server(SERVERPORT);\nESP8266HTTPUpdateServer httpUpdater;\n//mqttclient\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nlong lastMsg = 0;\nchar msg[50];\nint value = 0;\n\nvoid setup(void){  \n//  Init\npinMode(BUTTONPIN, INPUT);\npinMode(LEDPIN, OUTPUT);\npinMode(RELAYPIN, OUTPUT);\n\nSerial.begin(115200); \ndelay(5000);\n\n//Start wifi connection\nSerial.println("Connecting to wifi..");\nWiFi.begin(APSSID, APPASSWORD);\nWiFi.mode(WIFI_STA);\n\n//Print MAC to serial so we can use the address for auth if needed.\nprintMAC();\n\n// Wait for connection - Slow flash\nSerial.print("Waiting on Connection ...");\nwhile (WiFi.status() != WL_CONNECTED) {\n    digitalWrite(LEDPIN, LOW);\n    delay(500);\n    Serial.print(".");\n    //Serial.println(WiFi.status());\n    digitalWrite(LEDPIN, HIGH);\n    delay(500);\n}\nsetLED(false);\n//Print startup status and network information\nSerial.println("");\nSerial.print("Connected to: ");\nSerial.println(APSSID);\nSerial.print("IP: ");\nSerial.println(WiFi.localIP());\nSerial.print("Gateway: ");\nSerial.println(WiFi.gatewayIP());\nSerial.print("Subnet: ");  \nSerial.println(WiFi.subnetMask());\nSerial.print("Device ID: ");\nSerial.println(ESP.getChipId());\nif (mdns.begin("esp8266", WiFi.localIP())) {\n    Serial.println("MDNS: Responder Started");\n}\n\n//Setup HTTP Server Endpoints\nserver.on("/", HTTP_GET, handleGET);\nserver.on("/device", HTTP_POST, handleStatePOST);\nserver.on("/device", HTTP_GET, handleStateGET);\nserver.on("/state",HTTP_GET,RelayStateGET);\nserver.on("/change",HTTP_GET,RelayChange);\nserver.onNotFound(handleNotFound);\nhttpUpdater.setup(&server, OTAPATH, OTAUSER, OTAPASSWORD); //OTA Update endpoint\n\n//Start the web server\nserver.begin();\n\nclient.setServer(mqtt_server,mqtt_port);\nclient.setCallback(callback);\n\n\n//Start up blink of LED signaling everything is ready. Fast Flash\nfor (int i = 0; i < 10; i++) {\n    setLED(!LEDState);\n    delay(100);\n}\nSerial.println("Server is up.");\n\n//Enable periodic watcher for button event handling\nbuttonTick.attach(BUTTONTIME, buttonFlagSet);\n}\n\n//mqtt\nvoid mqtt_publish(char* message,const char* sender, const char* destination){\nif(!client.connected()){\n    reconnect();\n}\nclient.loop();\n\nchar output[256];\nStaticJsonDocument<256> doc;\n\ndoc["sender"] = sender;\ndoc["message"] = message;\ndoc["room"] = destination;\n\nserializeJson(doc, output);\n\nclient.publish(mqtt_topic, output);\n\ndelay(100);\n}\nvoid callback(char* topic, byte* payload, unsigned int length) {\nString Msg = "";\nint i=0;\nwhile (i<length) Msg += (char)payload[i++];\n\nStaticJsonDocument<256> doc;\nDeserializationError error = deserializeJson(doc, Msg.c_str(), length);\n\nif (error) {\n    Serial.print(F("deserializeJson() failed: "));\n    Serial.println(error.c_str());\n    char error_put[64];\n    StaticJsonDocument<64> doc;\n    doc["sender"] = "self";\n    doc["message"] = error.c_str();\n    doc["room"] = mqtt_id;\n    client.publish(mqtt_topic, error_put);\n    return;\n}\n\nconst char* sender = doc["Light"]["sender"];\nconst char* message = doc["Light"]["message"];\nconst char* destination = doc["Light"]["destination"];\nString message_str = message;\nString destination_str = destination;\n\nif(destination_str.equals("bathRoom2")){\n    if(message_str.equals("ON")){\n    if(RelayState == true){\n        mqtt_publish("already On", sender, destination);\n    }\n    else{\n        setRelay(!RelayState);\n        mqtt_publish("On", sender, destination);\n    }\n    }\n    else if(message_str.equals("STATE")){\n    if(RelayState == true){\n        mqtt_publish("On", sender, destination);\n    }\n    else{\n        mqtt_publish("Off", sender, destination);\n    }\n    }\n    else if(message_str.equals("OFF")){\n        if(RelayState == true){\n        setRelay(!RelayState);\n        mqtt_publish("Off", sender, destination);\n        }\n        else{\n        mqtt_publish("already Off", sender, destination);\n        }\n    }\n}\n} \nvoid reconnect() {\n// Loop until we\'re reconnected\nwhile (!client.connected()) {\n    Serial.print("Attempting MQTT connection...");\n    // Attempt to connect\n    if (client.connect(mqtt_id)) { //change to ClientID\n    Serial.println("connected");\n        \n    // ... and resubscribe\n    client.subscribe(mqtt_topic_sub);\n\n    // Once connected, publish an announcement...\n    client.publish(mqtt_topic_con, "{"sender":"self","message":"reconneted","room":"bathRoom2"}");\n        \n    } else {\n    Serial.print("failed, rc=");\n    Serial.print(client.state());\n    Serial.println(" try again in 5 seconds");\n    // Wait 5 seconds before retrying\n    delay(5000);\n    }\n}\n}\n/*\n* printMAC\n* Print the device MAC address to the serial port.\n*/\nvoid printMAC(void) {\nbyte mac[6];\nWiFi.macAddress(mac);\nSerial.print("MAC: ");\nSerial.print(mac[0],HEX);\nSerial.print(":");\nSerial.print(mac[1],HEX);\nSerial.print(":");\nSerial.print(mac[2],HEX);\nSerial.print(":");\nSerial.print(mac[3],HEX);\nSerial.print(":");\nSerial.print(mac[4],HEX);\nSerial.print(":");\nSerial.println(mac[5],HEX);\n}\n\n/* \n*  handleNotFound\n*  Return a 404 error on not found page.\n*/\nvoid handleNotFound() {\nserver.send(404, "text/plain", "404: Not found");\n}\n\n/* \n*  handleMainPage - GET\n*  Return Text for main page on GET\n*/\nvoid handleGET() {\n//Quick LED Flash\n//setLED(!LEDState);\n\n//Serve Page\nSerial.println("Serviced Page Request");\nString  buff;\nbuff  = "<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n";\nbuff += "<html><head>\n";\nbuff += "<style type="text/css">\n";\nbuff += "html {font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 10%; height:5vw; font-size: 100%; font-weight: bold; border-radius: 4vw;}\n";\nbuff += "@media (max-width: 1281px) {\n";\nbuff += "html {font-size: 3vw; font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 40%; height:20vw; font-size: 100%; font-weight: bold; border-radius: 15vw;}}\n";\nbuff += "</style>\n";\nbuff += "<meta content="text/html; charset=utf-8">\n";\nbuff += "<title>Mcity - Wifi Power Switch</title></head><body>\n";\nbuff += "</pre>\n";\nbuff += "Wifi-enabled IIoT Power Switch\n";\nbuff += "<form action="/device" method="POST">\n";\nbuff += "<h2>Device ID: " + String(ESP.getChipId()) + "</h2>\n";\nbuff += "<h2>Device topic: " + String(mqtt_topic_sub) + "</h2>\n";\nbuff += "<h2>Relay State: ";\nif (RelayState) {\n    buff += "ON</h2>\n";\n} else {\n    buff += "OFF</h2>\n";\n}\nbuff += "<input type="hidden" name="return" value="TRUE">";\nbuff += "<input type="submit" name="state" class="submit" value="ON" style="" + OnButt + "">\n";\nbuff += "<input type="submit" name="state" class="submit" value="OFF" style="" + OffButt + "">\n";\nbuff += "</form></body></html>\n";\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\nvoid RelayStateGET(){\n    String  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\nserver.send(200, "text/html", buff);\n}\nvoid RelayChange(){\nsetRelay(!RelayState);\nRelayStateGET();\n}\n/* \n*  handleStatePOST\n*  Modify state on POST\n*/\nvoid handleStatePOST() {\n/* request for www user/password from client */\nif (!server.authenticate(WWWUSERNAME, WWWPASSWORD))\n    return server.requestAuthentication();\nif (server.arg("state") == "ON") setRelay(true);\nif (server.arg("state") == "OFF") setRelay(false);\n\n//Redirect to home page is user requests it.\nif (server.arg("return") == "TRUE") handleGET();\nelse handleStateGET();\n}\n\n/* \n*  handleStateGET\n*  Print state on GET\n*/\nvoid handleStateGET() {    \n//Serve Page\nSerial.println("Serviced API Request");\n\n//Print Relay state\nString  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\n\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\n\n/* \n*  setRelay\n*  Sets the state of the Relay\n*/\nvoid setRelay(bool SetRelayState) {\n//Switch the HTML for the display page\nif (SetRelayState == true) {\n    OnButt  = BUTTONON;\n    OffButt = BUTTONNOACT;\n}\nif (SetRelayState == false) {\n    OnButt = BUTTONNOACT;\n    OffButt  = BUTTONOFF;\n}\n\n//Set the relay state\nRelayState = SetRelayState;\n\ndigitalWrite(RELAYPIN, RelayState);\n\n//Set the LED to opposite of the button.\n//setLED(!SetRelayState);\n}\n\n/*\n* setLED\n* Sets the state of the LED\n*/\nvoid setLED(bool SetLEDState) {\nLEDState = SetLEDState;     // set green LED\ndigitalWrite(LEDPIN, LEDState);\n}\n\n/*\n* ButtonFlagSet\n* Sets a variable so that on next loop, the button state is handled.\n*/\nvoid buttonFlagSet(void) {\nButtonFlag = true;\n}\n\n/* Read and handle button Press*/\nvoid getButton(void) {\n// short press butoon to change state of relay\nif (digitalRead(BUTTONPIN) == false ) {\n    ++ButtonCount;\n    }\nif (digitalRead(BUTTONPIN) == false && ButtonCount > 1 && ButtonCount < 12 ) {\n    setRelay(!RelayState); // change relay\n    if(RelayState==true){\n        client.publish(mqtt_topic,"{"sender":"self","message":"On","room":"bathRoom2"}"); \n    }\n    else{\n        client.publish(mqtt_topic,"{"sender":"self","message":"Off","room":"bathRoom2"}");\n    }\n    ButtonCount = 0;\n    delay(500);\n}\n/* long press button restart */\nif (ButtonCount > 12) {\n    setLED(!LEDState);\n    buttonTick.detach();    // Stop Tickers\n    /* Wait for release button */\n    while (!digitalRead(BUTTONPIN)) yield();\n    delay(100);\n    ESP.restart();\n}\nif (digitalRead(BUTTONPIN) == true) ButtonCount = 0;\nButtonFlag = false;\n}\n\n/*\n* loop\n* System Loop\n*/\nvoid loop(void){\nserver.handleClient();           // Listen for HTTP request\nif (ButtonFlag) getButton();// Handle the button press \nif(!client.connected()){\n    reconnect();\n}\nclient.loop();\n} \n\n']},connect:{len:1,title:[""],code:['#include <Ticker.h>\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include <ESP8266WebServer.h>\n#include <ESP8266mDNS.h>\n#include <ESP8266HTTPUpdateServer.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n\n#define APSSID          "wifi_id"   //AP SSID\n#define APPASSWORD      "wifi_password"         //AP password\n#define SERVERPORT      80         //Web server port\n#define WWWUSERNAME     "admin"    // Set www user name\n#define WWWPASSWORD     "admin"    // Set www user password\n#define OTAUSER         "otaAdmin"    // Set OTA user\n#define OTAPASSWORD     "otaAdmin"   // Set OTA password\n#define OTAPATH         "/firmware"// Set path for update\n#define RELAYPIN        15         // GPIO12 relay pin -> GPIO15\n#define LEDPIN          16         // GPIO13 GREEN LED (active low)-> GPIO16 change to wifi connect\n#define BUTTONPIN       5          // GPIO0 button pin -> GPIO5\n#define BUTTONTIME      0.05       // [s] time between button read\n#define BUTTONON        "color: green; border: 3px #fff outset;"\n#define BUTTONOFF       "color: red; border: 3px #fff outset;"\n#define BUTTONNOACT     "color: black; border: 7px #fff outset;"\n#define BUTTONDEBOUNCE  1 //Minimum number of seconds between a valid button press or relay switch.\n#define mqtt_server     "192.168.0.1"\n#define mqtt_port       1883\n#define mqtt_id         "test Room"\n#define mqtt_topic      "MyHome/Light/Sub/Server"\n#define mqtt_topic_sta  "MyHome/Light/Sub/Server/State"\n#define mqtt_topic_con  "MyHome/Light/Sub/Server/Connect"\n#define mqtt_topic_sub  "MyHome/Light/Pub/small Room"\n\nvolatile bool RelayState = false;   // Relay off\nbool LEDState = true;    // Green LED off\nbool ButtonFlag = false;   // Does the button need to be handled on this loop\nint ButtonCount = 0;       // How many cycles/checks the button has been pressed for.\nString OnButt;\nString OffButt;\n\n//Setup classes needed from libraries.\nMDNSResponder mdns;\nTicker buttonTick;\nESP8266WebServer server(SERVERPORT);\nESP8266HTTPUpdateServer httpUpdater;\n//mqttclient\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nlong lastMsg = 0;\nchar msg[50];\nint value = 0;\n\nvoid setup(void){  \n//  Init\npinMode(BUTTONPIN, INPUT);\npinMode(LEDPIN, OUTPUT);\npinMode(RELAYPIN, OUTPUT);\n\nSerial.begin(115200); \ndelay(5000);\n\n//Start wifi connection\nSerial.println("Connecting to wifi..");\nWiFi.begin(APSSID, APPASSWORD);\n\n//Print MAC to serial so we can use the address for auth if needed.\nprintMAC();\n\n// Wait for connection - Slow flash\nSerial.print("Waiting on Connection ...");\nwhile (WiFi.status() != WL_CONNECTED) {\n    digitalWrite(LEDPIN, LOW);\n    delay(500);\n    Serial.print(".");\n    //Serial.println(WiFi.status());\n    digitalWrite(LEDPIN, HIGH);\n    delay(500);\n}\n\nattachInterrupt(digitalPinToInterrupt(BUTTONPIN), reconnect, RISING);\n\nsetLED(false);\n//Print startup status and network information\nSerial.println("");\nSerial.print("Connected to: ");\nSerial.println(APSSID);\nSerial.print("IP: ");\nSerial.println(WiFi.localIP());\nSerial.print("Gateway: ");\nSerial.println(WiFi.gatewayIP());\nSerial.print("Subnet: ");  \nSerial.println(WiFi.subnetMask());\nSerial.print("Device ID: ");\nSerial.println(ESP.getChipId());\nif (mdns.begin("esp8266", WiFi.localIP())) {\n    Serial.println("MDNS: Responder Started");\n}\n\n//Setup HTTP Server Endpoints\nserver.on("/", HTTP_GET, handleGET);\nserver.on("/device", HTTP_POST, handleStatePOST);\nserver.on("/device", HTTP_GET, handleStateGET);\nserver.on("/state",HTTP_GET,RelayStateGET);\nserver.on("/change",HTTP_GET,RelayChange);\nserver.onNotFound(handleNotFound);\nhttpUpdater.setup(&server, OTAPATH, OTAUSER, OTAPASSWORD); //OTA Update endpoint\n\n//Start the web server\nserver.begin();\n\nclient.setServer(mqtt_server,mqtt_port);\nclient.setCallback(callback);\n\n\n//Start up blink of LED signaling everything is ready. Fast Flash\nfor (int i = 0; i < 10; i++) {\n    setLED(!LEDState);\n    delay(100);\n}\nSerial.println("Server is up.");\nSerial.println(digitalRead(BUTTONPIN));\n\n//Enable periodic watcher for button event handling\nbuttonTick.attach(BUTTONTIME, buttonFlagSet);\n}\n\n//mqtt\nvoid mqtt_publish(const char* message,const char* sender){\nif(!client.connected()){\n    reconnect();\n}\nclient.loop();\n\nchar output[256];\nStaticJsonDocument<256> doc;\n\ndoc["sender"] = sender;\ndoc["message"] = message;\ndoc["room"] = mqtt_id;\n\nserializeJson(doc, output);\n\nclient.publish(mqtt_topic, output);  \n\ndelay(100);\n}\nvoid callback(char* topic, byte* payload, unsigned int length) {\nString Msg = "";\nint i=0;\nwhile (i<length) Msg += (char)payload[i++];\n\nStaticJsonDocument<256> doc;\nDeserializationError error = deserializeJson(doc, Msg.c_str(), length);\n\nif (error) {\n    Serial.print(F("deserializeJson() failed: "));\n    Serial.println(error.c_str());\n    char error_put[64];\n    StaticJsonDocument<64> doc;\n    doc["sender"] = "self";\n    doc["message"] = error.c_str();\n    doc["room"] = mqtt_id;\n    client.publish(mqtt_topic, error_put);\n    return;\n}\n\nconst char* sender = doc["Light"]["sender"];\nconst char* message = doc["Light"]["message"];\nconst char* destination = doc["Light"]["destination"];\nconst char* msgAlreadyOn = "already On";\nconst char* msgAlreadyOff = "already Off";\nconst char* msgOn = "On";\nconst char* msgOff = "Off";\nString message_str = message;\nString destination_str = destination;\n\nif(message_str.equals("ON")){\n    if(RelayState == true){\n    mqtt_publish(msgAlreadyOn, sender);\n    }\n    else{\n    setRelay(!RelayState);\n    mqtt_publish(msgOn, sender);\n    }\n}\nelse if(message_str.equals("STATE")){\n    if(RelayState == true){\n    mqtt_publish(msgOn, sender);\n    }\n    else{\n    mqtt_publish(msgOff, sender);\n    }\n}\nelse{\n    if(message_str.equals("OFF")){\n    if(RelayState == true){\n        setRelay(!RelayState);\n        mqtt_publish(msgOff, sender);\n    }\n    else{\n        mqtt_publish(msgAlreadyOff, sender);\n    }\n    }\n}\n} \nvoid reconnect() {\n// Loop until we\'re reconnected\n    Serial.print("Attempting MQTT connection...");\n    // Attempt to connect\n    if (client.connect(mqtt_id)) { //change to ClientID\n    Serial.println("connected");\n        \n    // ... and resubscribe\n    client.subscribe(mqtt_topic_sub);\n\n    // Once connected, publish an announcement...\n    client.publish(mqtt_topic_con, "{"sender":"self","message":"reconneted","room":"small Room"}");\n        \n    } else {\n    Serial.print("failed, rc=");\n    Serial.println(client.state());\n    // Serial.println(" try again in 5 seconds");\n    // Wait 5 seconds before retrying\n    // delay(5000);\n    }\n\n}\n/*\n* printMAC\n* Print the device MAC address to the serial port.\n*/\nvoid printMAC(void) {\nbyte mac[6];\nWiFi.macAddress(mac);\nSerial.print("MAC: ");\nSerial.print(mac[0],HEX);\nSerial.print(":");\nSerial.print(mac[1],HEX);\nSerial.print(":");\nSerial.print(mac[2],HEX);\nSerial.print(":");\nSerial.print(mac[3],HEX);\nSerial.print(":");\nSerial.print(mac[4],HEX);\nSerial.print(":");\nSerial.println(mac[5],HEX);\n}\n\n/* \n*  handleNotFound\n*  Return a 404 error on not found page.\n*/\nvoid handleNotFound() {\nserver.send(404, "text/plain", "404: Not found");\n}\n\n/* \n*  handleMainPage - GET\n*  Return Text for main page on GET\n*/\nvoid handleGET() {\n//Quick LED Flash\n//setLED(!LEDState);\n\n//Serve Page\nSerial.println("Serviced Page Request");\nString  buff;\nbuff  = "<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n";\nbuff += "<html><head>\n";\nbuff += "<style type="text/css">\n";\nbuff += "html {font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 10%; height:5vw; font-size: 100%; font-weight: bold; border-radius: 4vw;}\n";\nbuff += "@media (max-width: 1281px) {\n";\nbuff += "html {font-size: 3vw; font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 40%; height:20vw; font-size: 100%; font-weight: bold; border-radius: 15vw;}}\n";\nbuff += "</style>\n";\nbuff += "<meta content="text/html; charset=utf-8">\n";\nbuff += "<title>Mcity - Wifi Power Switch</title></head><body>\n";\nbuff += "</pre>\n";\nbuff += "Wifi-enabled IIoT Power Switch\n";\nbuff += "<form action="/device" method="POST">\n";\nbuff += "<h2>Device ID: " + String(ESP.getChipId()) + "</h2>\n";\nbuff += "<h2>Device topic: " + String(mqtt_topic_sub) + "</h2>\n";\nbuff += "<h2>Relay State: ";\nif (RelayState) {\n    buff += "ON</h2>\n";\n} else {\n    buff += "OFF</h2>\n";\n}\nbuff += "<input type="hidden" name="return" value="TRUE">";\nbuff += "<input type="submit" name="state" class="submit" value="ON" style="" + OnButt + "">\n";\nbuff += "<input type="submit" name="state" class="submit" value="OFF" style="" + OffButt + "">\n";\nbuff += "</form></body></html>\n";\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\nvoid RelayStateGET(){\n    String  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\nserver.send(50, "text/html", buff);\n}\nvoid RelayChange(){\nsetRelay(!RelayState);\nRelayStateGET();\n}\n/* \n*  handleStatePOST\n*  Modify state on POST\n*/\nvoid handleStatePOST() {\n/* request for www user/password from client */\nif (!server.authenticate(WWWUSERNAME, WWWPASSWORD))\n    return server.requestAuthentication();\nif (server.arg("state") == "ON") setRelay(true);\nif (server.arg("state") == "OFF") setRelay(false);\n\n//Redirect to home page is user requests it.\nif (server.arg("return") == "TRUE") handleGET();\nelse handleStateGET();\n}\n\n/* \n*  handleStateGET\n*  Print state on GET\n*/\nvoid handleStateGET() {    \n//Serve Page\nSerial.println("Serviced API Request");\n\n//Print Relay state\nString  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\n\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\n\n/* \n*  setRelay\n*  Sets the state of the Relay\n*/\nvoid setRelay(bool SetRelayState) {\n//Switch the HTML for the display page\nif (SetRelayState == true) {\n    OnButt  = BUTTONON;\n    OffButt = BUTTONNOACT;\n}\nif (SetRelayState == false) {\n    OnButt = BUTTONNOACT;\n    OffButt  = BUTTONOFF;\n}\n\n//Set the relay state\nRelayState = SetRelayState;\n\ndigitalWrite(RELAYPIN, RelayState);\n\n//Set the LED to opposite of the button.\n//setLED(!SetRelayState);\n}\n\n/*\n* setLED\n* Sets the state of the LED\n*/\nvoid setLED(bool SetLEDState) {\nLEDState = SetLEDState;     // set green LED\ndigitalWrite(LEDPIN, LEDState);\n}\n\n/*\n* ButtonFlagSet\n* Sets a variable so that on next loop, the button state is handled.\n*/\nvoid buttonFlagSet(void) {\nButtonFlag = true;\n}\n\nICACHE_RAM_ATTR void ButtonInterrupt() {\nsetRelay(!RelayState); // change relay\n}\n\n/* Read and handle button Press*/\nvoid getButton(void) {\n  // short press butoon to change state of relay\n  if (digitalRead(BUTTONPIN) == false ) {\n    ++ButtonCount;\n    }\n  if (digitalRead(BUTTONPIN) == false && ButtonCount > 1 && ButtonCount < 12 ) {\n    setRelay(!RelayState); // change relay\n      if(RelayState==true){\n        client.publish(mqtt_topic,"{"sender":"self","message":"On","room":"bathRoom2"}"); \n      }\n      else{\n        client.publish(mqtt_topic,"{"sender":"self","message":"Off","room":"bathRoom2"}");\n      }\n      ButtonCount = 0;\n      delay(500);\n  }\n  /* long press button restart */\n  if (ButtonCount > 12) {\n    setLED(!LEDState);\n    buttonTick.detach();    // Stop Tickers\n    /* Wait for release button */\n    while (!digitalRead(BUTTONPIN)) yield();\n    delay(100);\n    ESP.restart();\n  }\n  if (digitalRead(BUTTONPIN) == true) ButtonCount = 0;\n  ButtonFlag = false;\n}\n\n/*\n* loop\n* System Loop\n*/\nvoid loop(void){\nserver.handleClient();           // Listen for HTTP request\nif(ButtonFlag) {\n    getButton(); // Handle the button press to work mqtt\n}\nclient.loop();\n} \n']},control:{len:1,title:["Divide MQTT, button event use by interrupt"],code:['#include <Ticker.h>\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include <ESP8266WebServer.h>\n#include <ESP8266mDNS.h>\n#include <ESP8266HTTPUpdateServer.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n\n#define APSSID          "wifi_id"   //AP SSID\n#define APPASSWORD      "wifi_password"         //AP password\n#define SERVERPORT      80         //Web server port\n#define WWWUSERNAME     "admin"    // Set www user name\n#define WWWPASSWORD     "admin"    // Set www user password\n#define OTAUSER         "otaAdmin"    // Set OTA user\n#define OTAPASSWORD     "otaAdmin"   // Set OTA password\n#define OTAPATH         "/firmware"// Set path for update\n#define RELAYPIN        15         // GPIO12 relay pin -> GPIO15\n#define LEDPIN          16         // GPIO13 GREEN LED (active low)-> GPIO16 change to wifi connect\n#define BUTTONPIN       5          // GPIO0 button pin -> GPIO5\n#define BUTTONTIME      0.05       // [s] time between button read\n#define BUTTONON        "color: green; border: 3px #fff outset;"\n#define BUTTONOFF       "color: red; border: 3px #fff outset;"\n#define BUTTONNOACT     "color: black; border: 7px #fff outset;"\n#define BUTTONDEBOUNCE  1 //Minimum number of seconds between a valid button press or relay switch.\n#define mqtt_server     "192.168.0.1"\n#define mqtt_port       1883\n#define mqtt_id         "test Room"\n#define mqtt_topic      "MyHome/Light/Sub/Server"\n#define mqtt_topic_sta  "MyHome/Light/Sub/Server/State"\n#define mqtt_topic_con  "MyHome/Light/Sub/Server/Connect"\n#define mqtt_topic_sub  "MyHome/Light/Pub/small Room"\n\nvolatile bool RelayState = false;   // Relay off\nbool LEDState = true;    // Green LED off\nbool ButtonFlag = false;   // Does the button need to be handled on this loop\nint ButtonCount = 0;       // How many cycles/checks the button has been pressed for.\nString OnButt;\nString OffButt;\n\n//Setup classes needed from libraries.\nMDNSResponder mdns;\nTicker buttonTick;\nESP8266WebServer server(SERVERPORT);\nESP8266HTTPUpdateServer httpUpdater;\n//mqttclient\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nlong lastMsg = 0;\nchar msg[50];\nint value = 0;\n\nvoid setup(void){  \n//  Init\npinMode(BUTTONPIN, INPUT);\npinMode(LEDPIN, OUTPUT);\npinMode(RELAYPIN, OUTPUT);\n\nSerial.begin(115200); \ndelay(5000);\n\n//Start wifi connection\nSerial.println("Connecting to wifi..");\nWiFi.begin(APSSID, APPASSWORD);\n\n//Print MAC to serial so we can use the address for auth if needed.\nprintMAC();\n\n// Wait for connection - Slow flash\nSerial.print("Waiting on Connection ...");\nwhile (WiFi.status() != WL_CONNECTED) {\n    digitalWrite(LEDPIN, LOW);\n    delay(500);\n    Serial.print(".");\n    //Serial.println(WiFi.status());\n    digitalWrite(LEDPIN, HIGH);\n    delay(500);\n}\n\nattachInterrupt(digitalPinToInterrupt(BUTTONPIN), ButtonInterrupt, RISING);\n\nsetLED(false);\n//Print startup status and network information\nSerial.println("");\nSerial.print("Connected to: ");\nSerial.println(APSSID);\nSerial.print("IP: ");\nSerial.println(WiFi.localIP());\nSerial.print("Gateway: ");\nSerial.println(WiFi.gatewayIP());\nSerial.print("Subnet: ");  \nSerial.println(WiFi.subnetMask());\nSerial.print("Device ID: ");\nSerial.println(ESP.getChipId());\nif (mdns.begin("esp8266", WiFi.localIP())) {\n    Serial.println("MDNS: Responder Started");\n}\n\n//Setup HTTP Server Endpoints\nserver.on("/", HTTP_GET, handleGET);\nserver.on("/device", HTTP_POST, handleStatePOST);\nserver.on("/device", HTTP_GET, handleStateGET);\nserver.on("/state",HTTP_GET,RelayStateGET);\nserver.on("/change",HTTP_GET,RelayChange);\nserver.onNotFound(handleNotFound);\nhttpUpdater.setup(&server, OTAPATH, OTAUSER, OTAPASSWORD); //OTA Update endpoint\n\n//Start the web server\nserver.begin();\n\nclient.setServer(mqtt_server,mqtt_port);\nclient.setCallback(callback);\n\n\n//Start up blink of LED signaling everything is ready. Fast Flash\nfor (int i = 0; i < 10; i++) {\n    setLED(!LEDState);\n    delay(100);\n}\nSerial.println("Server is up.");\nSerial.println(digitalRead(BUTTONPIN));\n\n//Enable periodic watcher for button event handling\nbuttonTick.attach(BUTTONTIME, buttonFlagSet);\n}\n\n//mqtt\nvoid mqtt_publish(const char* message,const char* sender){\nif(!client.connected()){\n    reconnect();\n}\nclient.loop();\n\nchar output[256];\nStaticJsonDocument<256> doc;\n\ndoc["sender"] = sender;\ndoc["message"] = message;\ndoc["room"] = mqtt_id;\n\nserializeJson(doc, output);\n\nclient.publish(mqtt_topic, output);  \n\ndelay(100);\n}\nvoid callback(char* topic, byte* payload, unsigned int length) {\nString Msg = "";\nint i=0;\nwhile (i<length) Msg += (char)payload[i++];\n\nStaticJsonDocument<256> doc;\nDeserializationError error = deserializeJson(doc, Msg.c_str(), length);\n\nif (error) {\n    Serial.print(F("deserializeJson() failed: "));\n    Serial.println(error.c_str());\n    char error_put[64];\n    StaticJsonDocument<64> doc;\n    doc["sender"] = "self";\n    doc["message"] = error.c_str();\n    doc["room"] = mqtt_id;\n    client.publish(mqtt_topic, error_put);\n    return;\n}\n\nconst char* sender = doc["Light"]["sender"];\nconst char* message = doc["Light"]["message"];\nconst char* destination = doc["Light"]["destination"];\nconst char* msgAlreadyOn = "already On";\nconst char* msgAlreadyOff = "already Off";\nconst char* msgOn = "On";\nconst char* msgOff = "Off";\nString message_str = message;\nString destination_str = destination;\n\nif(message_str.equals("ON")){\n    if(RelayState == true){\n    mqtt_publish(msgAlreadyOn, sender);\n    }\n    else{\n    setRelay(!RelayState);\n    mqtt_publish(msgOn, sender);\n    }\n}\nelse if(message_str.equals("STATE")){\n    if(RelayState == true){\n    mqtt_publish(msgOn, sender);\n    }\n    else{\n    mqtt_publish(msgOff, sender);\n    }\n}\nelse{\n    if(message_str.equals("OFF")){\n    if(RelayState == true){\n        setRelay(!RelayState);\n        mqtt_publish(msgOff, sender);\n    }\n    else{\n        mqtt_publish(msgAlreadyOff, sender);\n    }\n    }\n}\n} \nvoid reconnect() {\n// Loop until we\'re reconnected\n    Serial.print("Attempting MQTT connection...");\n    // Attempt to connect\n    if (client.connect(mqtt_id)) { //change to ClientID\n    Serial.println("connected");\n        \n    // ... and resubscribe\n    client.subscribe(mqtt_topic_sub);\n\n    // Once connected, publish an announcement...\n    client.publish(mqtt_topic_con, "{"sender":"self","message":"reconneted","room":"small Room"}");\n        \n    } else {\n    Serial.print("failed, rc=");\n    Serial.println(client.state());\n    // Serial.println(" try again in 5 seconds");\n    // Wait 5 seconds before retrying\n    // delay(5000);\n    }\n\n}\n/*\n* printMAC\n* Print the device MAC address to the serial port.\n*/\nvoid printMAC(void) {\nbyte mac[6];\nWiFi.macAddress(mac);\nSerial.print("MAC: ");\nSerial.print(mac[0],HEX);\nSerial.print(":");\nSerial.print(mac[1],HEX);\nSerial.print(":");\nSerial.print(mac[2],HEX);\nSerial.print(":");\nSerial.print(mac[3],HEX);\nSerial.print(":");\nSerial.print(mac[4],HEX);\nSerial.print(":");\nSerial.println(mac[5],HEX);\n}\n\n/* \n*  handleNotFound\n*  Return a 404 error on not found page.\n*/\nvoid handleNotFound() {\nserver.send(404, "text/plain", "404: Not found");\n}\n\n/* \n*  handleMainPage - GET\n*  Return Text for main page on GET\n*/\nvoid handleGET() {\n//Quick LED Flash\n//setLED(!LEDState);\n\n//Serve Page\nSerial.println("Serviced Page Request");\nString  buff;\nbuff  = "<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">\n";\nbuff += "<html><head>\n";\nbuff += "<style type="text/css">\n";\nbuff += "html {font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 10%; height:5vw; font-size: 100%; font-weight: bold; border-radius: 4vw;}\n";\nbuff += "@media (max-width: 1281px) {\n";\nbuff += "html {font-size: 3vw; font-family: sans-serif;background:#f0f5f5}\n";\nbuff += ".submit {width: 40%; height:20vw; font-size: 100%; font-weight: bold; border-radius: 15vw;}}\n";\nbuff += "</style>\n";\nbuff += "<meta content="text/html; charset=utf-8">\n";\nbuff += "<title>Mcity - Wifi Power Switch</title></head><body>\n";\nbuff += "</pre>\n";\nbuff += "Wifi-enabled IIoT Power Switch\n";\nbuff += "<form action="/device" method="POST">\n";\nbuff += "<h2>Device ID: " + String(ESP.getChipId()) + "</h2>\n";\nbuff += "<h2>Device topic: " + String(mqtt_topic_sub) + "</h2>\n";\nbuff += "<h2>Relay State: ";\nif (RelayState) {\n    buff += "ON</h2>\n";\n} else {\n    buff += "OFF</h2>\n";\n}\nbuff += "<input type="hidden" name="return" value="TRUE">";\nbuff += "<input type="submit" name="state" class="submit" value="ON" style="" + OnButt + "">\n";\nbuff += "<input type="submit" name="state" class="submit" value="OFF" style="" + OffButt + "">\n";\nbuff += "</form></body></html>\n";\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\nvoid RelayStateGET(){\n    String  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\nserver.send(50, "text/html", buff);\n}\nvoid RelayChange(){\nsetRelay(!RelayState);\nRelayStateGET();\n}\n/* \n*  handleStatePOST\n*  Modify state on POST\n*/\nvoid handleStatePOST() {\n/* request for www user/password from client */\nif (!server.authenticate(WWWUSERNAME, WWWPASSWORD))\n    return server.requestAuthentication();\nif (server.arg("state") == "ON") setRelay(true);\nif (server.arg("state") == "OFF") setRelay(false);\n\n//Redirect to home page is user requests it.\nif (server.arg("return") == "TRUE") handleGET();\nelse handleStateGET();\n}\n\n/* \n*  handleStateGET\n*  Print state on GET\n*/\nvoid handleStateGET() {    \n//Serve Page\nSerial.println("Serviced API Request");\n\n//Print Relay state\nString  buff;\nif (RelayState) {\n    buff = "ON\n";\n} else {\n    buff = "OFF\n";\n}\n\nserver.send(200, "text/html", buff);\n\n//Quick LED Flash\ndelay(20);\n//setLED(!LEDState);\n}\n\n/* \n*  setRelay\n*  Sets the state of the Relay\n*/\nvoid setRelay(bool SetRelayState) {\n//Switch the HTML for the display page\nif (SetRelayState == true) {\n    OnButt  = BUTTONON;\n    OffButt = BUTTONNOACT;\n}\nif (SetRelayState == false) {\n    OnButt = BUTTONNOACT;\n    OffButt  = BUTTONOFF;\n}\n\n//Set the relay state\nRelayState = SetRelayState;\n\ndigitalWrite(RELAYPIN, RelayState);\n\n//Set the LED to opposite of the button.\n//setLED(!SetRelayState);\n}\n\n/*\n* setLED\n* Sets the state of the LED\n*/\nvoid setLED(bool SetLEDState) {\nLEDState = SetLEDState;     // set green LED\ndigitalWrite(LEDPIN, LEDState);\n}\n\n/*\n* ButtonFlagSet\n* Sets a variable so that on next loop, the button state is handled.\n*/\nvoid buttonFlagSet(void) {\nButtonFlag = true;\n}\n\nICACHE_RAM_ATTR void ButtonInterrupt() {\nsetRelay(!RelayState); // change relay\n}\n\n/* Read and handle button Press*/\nvoid getButton(void) {\n// short press butoon to change state of relay\nif (digitalRead(BUTTONPIN) == false ) {\n    ++ButtonCount;\n    }\nif (digitalRead(BUTTONPIN) == false && ButtonCount > 1 && ButtonCount < 12 ) {\n    Serial.println(RelayState);\n    if(RelayState==false){\n        client.publish(mqtt_topic,"{"sender":"self","message":"On","room":"small Room"}"); \n    }\n    else{\n        client.publish(mqtt_topic,"{"sender":"self","message":"Off","room":"small Room"}");\n    }\n    ButtonCount = 0;\n    delay(500);\n}\n/* long press button restart */\nif (ButtonCount > 12) {\n    setLED(!LEDState);\n    buttonTick.detach();    // Stop Tickers\n    /* Wait for release button */\n    while (!digitalRead(BUTTONPIN)) yield();\n    delay(100);\n    ESP.restart();\n}\nif (digitalRead(BUTTONPIN) == true) ButtonCount = 0;\nButtonFlag = false;\n}\n\n/*\n* loop\n* System Loop\n*/\nvoid loop(void){\nserver.handleClient();           // Listen for HTTP request\nif(!client.connected()){\n    reconnect();\n}\nelse {\n    if(ButtonFlag) {\n    getButton(); // Handle the button press to work mqtt\n    }\n}\nclient.loop();\n} \n']}}},S={tmp:{tmp:{len:0,title:[""],path:[""]}},android:{tmp:{len:0,title:[],path:[]},sdk:{len:0,title:[],path:[]},broadcast:{len:0,title:[],path:[]},retrofit2:{len:0,title:[],path:[]},fragment:{len:2,title:["MainActivity","LightActivity"],path:["android_main.png","android_light.png"]},component:{len:1,title:["MainActivity"],path:["android_main.png"]},thumbnail:{len:1,title:["Thumbnail"],path:["thumbnail.jpg"]},mvvm:{len:1,title:["MVVM Pattern"],path:["mvvm.png"]},defaultInfo:{len:0,title:[],path:[]},enum:{len:0,title:[],path:[]}},backend:{jwt:{len:0,title:[],path:[]},rule:{len:1,title:["Rule( = AUTH_CHAR) in DB"],path:["rule.png"]},jwtFilter:{len:0,title:[],path:[]},whiteList:{len:0,title:[],path:[]},customFilter:{len:0,title:[],path:[]},weatherFeature:{len:0,title:[],path:[]},iotFeature:{len:0,title:[],path:[]},sftp:{len:0,title:[],path:[]},fullSearch:{len:0,title:[],path:[]},thumbnail:{len:0,title:[],path:[]},batch:{len:0,title:[],path:[]},lowQualityImage:{len:0,title:[],path:[]},walksAndBulk:{len:0,title:[],path:[]},CIAndCD:{len:1,title:["CI / CD with Jenkins"],path:["CIAndCD.png"]},restart:{len:1,title:["Restart Option(Jenkins deploy path)"],path:["restart.png"]},container:{len:1,title:["Docker Container List"],path:["container.png"]},weatherMaintenance:{len:0,title:[],path:[]},cloud:{len:0,title:[],path:[]},onlyLogic:{len:0,title:[],path:[]},migration:{len:1,title:["Python Script → Django"],path:["migration.png"]},buildLogSystem:{len:3,title:["Log in Kafka","Log in Web","Log in Web(Detail)"],path:["log.png","log_page.png","log_detail.png"]},logDivPart:{len:1,title:["Divide logging part"],path:["divlog.png"]},block:{len:1,title:["Build path Block by Service(feature)"],path:["block.png"]},enum:{len:0,title:[],path:[]}},iot:{tmp:{len:0,title:[],path:[]},origin:{len:0,title:[],path:[]},connect:{len:0,title:[],path:[]},control:{len:0,title:[],path:[]}}},f=t(7925),h=t(89285),b=t(11163);function T(e){let{part:n,name:t,codeType:T,title:P,content:y,problems:R,solved:v,show:E,handleStatus:O}=e,[I,A]=r.useState(!1),[C,L]=r.useState(""),w=(0,f.CG)(e=>e.page.smallMode),D=w?14:16,{prefix:F}=r.useContext(h.ZP);(0,b.useRouter)();let _=m[n][t].len,N=m[n][t].title,B=m[n][t].code,k=S[n][t].len,x=S[n][t].title,M=S[n][t].path,U=()=>{A(!1),O()},W=()=>{A(!I),O()},H=e=>{L(e),A(!0),O()};return(0,i.jsxs)(l.Z,{sx:{borderRadius:"50%"},children:[(0,i.jsx)(o.Z,{disablePortal:!0,disableEnforceFocus:!0,disableAutoFocus:!0,open:I,onClose:W,"aria-labelledby":"server-modal-title","aria-describedby":"server-modal-description",sx:{display:"flex",p:1,alignItems:"center",justifyContent:"center"},children:(0,i.jsxs)(l.Z,{sx:{textAlign:"right"},children:[(0,i.jsx)(s.Z,{"aria-label":"close",onClick:W,children:(0,i.jsx)(g.Z,{})}),(0,i.jsx)("img",{src:"".concat(F,"/image/image/").concat(C),style:{maxHeight:"80vh",maxWidth:"80vw"}})]})}),(0,i.jsx)(o.Z,{disablePortal:!0,disableEnforceFocus:!0,disableAutoFocus:!0,open:E,onClose:U,"aria-labelledby":"server-modal-title","aria-describedby":"server-modal-description",sx:{display:"flex",p:1,alignItems:"center",justifyContent:"center"},children:(0,i.jsx)("div",{style:{backgroundColor:"#f4f5ff",borderRadius:"1rem",width:w?"95%":"85%",height:w?"95%":"85%"},children:(0,i.jsxs)(l.Z,{sx:{margin:"1rem",height:"100%"},children:[(0,i.jsx)(l.Z,{sx:{width:"100%",textAlign:"right"},children:(0,i.jsx)(s.Z,{"aria-label":"close",onClick:U,children:(0,i.jsx)(g.Z,{})})}),(0,i.jsxs)(u.ZP,{container:!0,direction:"row",style:{height:"100%"},children:[(0,i.jsx)(u.ZP,{item:!0,xs:12,sm:12,md:3,lg:3,style:{height:w?"10%":"90%"},children:(0,i.jsxs)(l.Z,{sx:{margin:"0.5rem"},children:[(0,i.jsx)(a.Z,{variant:"overline",fontSize:D,fontWeight:"bolder",children:"\uD83D\uDCD9 problem"}),(0,i.jsx)(a.Z,{fontWeight:"bolder",children:P}),(0,i.jsx)(d.Z,{style:{marginTop:w?"0":"1.5rem",marginBottom:w?"0":"1.5rem"}}),(0,i.jsx)(a.Z,{variant:"overline",fontSize:D,children:"\uD83D\uDCC3 Solution"}),(0,i.jsx)(a.Z,{children:y})]})}),(0,i.jsx)(u.ZP,{item:!0,xs:12,sm:12,md:9,lg:9,style:{height:w?"55%":"85%"},children:(0,i.jsxs)(c.Z,{style:{margin:w?"0":"0.5rem",height:"100%",overflowY:"auto",overscrollBehavior:"auto"},children:[R.map((e,n)=>(0,i.jsxs)("div",{style:{margin:"0.5rem"},children:[(0,i.jsxs)(a.Z,{variant:"overline",fontSize:D,fontWeight:"bolder",children:["\uD83D\uDCD5 problem ",n+1,"."]}),(0,i.jsx)(a.Z,{children:R[n]}),(0,i.jsxs)(a.Z,{variant:"overline",fontSize:D,children:["\uD83D\uDCD6 Solution ",n+1,"."]}),(0,i.jsx)(a.Z,{children:v[n]}),(0,i.jsx)("br",{}),_>n&&(0,i.jsxs)("div",{children:[(0,i.jsxs)(a.Z,{children:["\uD83E\uDDFE Code ",n+1,". ",N[n]]}),(0,i.jsx)("div",{style:{fontSize:14},children:(0,i.jsx)(p.dn,{language:T,showLineNumbers:!0,theme:p.cL,text:B[n]})})]})]},n)),k>0&&(0,i.jsxs)("div",{children:[(0,i.jsx)(a.Z,{variant:"overline",fontSize:D,fontWeight:"bolder",marginLeft:"0.5rem",children:"\uD83D\uDCF8 screenshot"}),(0,i.jsx)(a.Z,{fontSize:.8*D,marginLeft:"0.5rem",marginBottom:"0.9rem",children:"※ 이미지를 클릭 시, 확대됩니다."}),M.map((e,n)=>(0,i.jsxs)("div",{style:{margin:"0.5rem"},children:[(0,i.jsxs)(a.Z,{children:["◽ ",x[n]]}),(0,i.jsx)("br",{}),(0,i.jsx)("img",{src:"".concat(F,"/image/image/").concat(e),onClick:()=>H(e),style:{cursor:"pointer"}}),(0,i.jsx)("br",{})]},n))]})]})})]})]})})})]})}},33201:function(e,n,t){t.d(n,{Z:function(){return d}});var i=t(85893),r=t(90948),o=t(5616),a=t(15861),l=t(7925),s={android:{tmp:{title:"",content:"",problem:[""],solution:[""]},sdk:{title:"SDK 업데이트 필요",content:"28 → 34로 업데이트",problem:["Android SDK를 유저 기기(최소 SDK 33)에 맞게 업데이트 필요."],solution:["Android SDK를 28에서 34로 업데이트 및 레거시 코드 or 라이브러리도 업데이트"]},broadcast:{title:"보안을 위해 MQTT 리스너 값 브로드캐스트 범위 축소",content:"브로드캐스트 범위 글로벌에서 로컬로 변경",problem:["업데이트 된 SDK의 보안 정책에 따라 MQTT 리스너에 들어온 값들을 여러 엑티비티가 공유할 수 있도록 방송하는 범위를 줄여야 함."],solution:["브로드캐스트 범위를 글로벌에서 로컬로 변경하여 앱 안에서만 하도록 설정."]},retrofit2:{title:"네트워크 라이브러리 변경",content:"Retrofit 2으로 변경",problem:["AsyncTask가 레거시 코드로 분류됨으로써, 새로운 네트워크 라이브러리가 필요."],solution:["백엔드 서비스를 REST API로 전부 변경하였기에 이에 잘맞는 라이브러리인 Retrofit2로 변경."]},fragment:{title:"기능들이 한 페이지 안에 들어오지 않음",content:"Fragment를 이용하여 최대한 페이지 벗어나지 않게 함",problem:["기능들을 확인하고 사용하려면 페이지 이동을 세부 메뉴로 이동을 계속 해야함."],solution:["Fragment를 통해 메인 기능들을 최대한 이동 없이 직관적으로 확인 할 수 있도록 변경 함."]},component:{title:"컴포넌트 사이즈가 작아 가독성이 좋지 않음",content:"컴포넌트 사이즈를 키워서 해결",problem:["기존 컴포넌트는 사이즈가 작아서 내부의 글 혹은 정보를 읽는 가독성이 좋지 않음."],solution:["컴포넌트 사이즈를 키우고 정보도 직관적으로 변경하여 정보 가독성을 증가 시킴."]},thumbnail:{title:"이미지 혹은 비디오 파일 정보를 미리 확인하고 싶음",content:"썸네일 기능을 이용하여 제공",problem:["이미지 혹은 비디오 파일을 세부정보 확인 전에 미리 어떤 파일인지 확인하고 싶음."],solution:["썸네일 기능을 이용하여 해당 파일에 대한 정보를 미리 제공."]},mvvm:{title:"안드로이드 코드 유지 보수 위한 패턴 필요",content:"MVVM 패턴을 적용",problem:["유지 보수을 수월하게 하기 위해 디자인 패턴이 필요하다는 것을 리팩토링을 통해 절실히 느낌."],solution:["MVVM 패턴을 이용하여 Model, ViewModel, View로 나뉘어서 기능과 view 그리고 연결 파트로 나눠 코드 유지보수를 수월하게 함."]},defaultInfo:{title:"기본 정보에 관한 유지보수를 쉽게 하고자 함",content:"하드코딩으로 적힌 데이터를 DB로 이관함",problem:["기본 정보에 관련된 데이터가 하드 코딩으로 되어 있어서 유지보수 향상을 위해 변경 필요."],solution:["해당 데이터를 DB로 이관하여 데이터가 변경이 되더라도 클라이언트 업데이트 필요가 없도록 변경함."]},enum:{title:"여러곳에서 사용되는 고정 데이터를 일괄적으로 적용하고자 함",content:"ENUM을 사용",problem:["여러 코드에서 사용되는 데이터를 하드코딩 대신 일괄적으로 적용하고자 함."],solution:["enum을 이용하여 데이터를 일괄적으로 적용하여 만약 변경이 필요할 경우 enum에 있는 해당 데이터만 변경하도록 적용."]}},backend:{jwt:{title:"서버 ↔ 클라이언트 통신 간 데이터 보안 필요",content:"JWT 적용",problem:["기존에는 api 호출 할때 유저 정보가 필요 시, 별도의 암호화 없이 그대로 전송하였기에 정보가 중간에 탈취 될 경우 그대로 정보가 유출되기에 암호화 하여 통신을 하도록 변경해야함."],solution:["JWT를 이용하여 토큰을 이용하여 개인 인증을 하도록 변경. 토큰에 저장되는 값도 민감하지 않은 정보를 이용하여 혹시나 경우를 대비."]},rule:{title:"계정 별 접근 권한 분리 필요",content:"Rule을 부여하여 계정 별 서비스 접근 권한 부여",problem:["기존에는 회원가입만 할 경우 누구나 서비스 접근 가능한 문제가 존재. 서비스의 접근성이 넓어진 만큼 외부인원이 함부로 서비스를 사용하지 못하도록 제한을 걸어야 할 필요성 제기."],solution:["계정 정보에 Rule을 추가하여 정회원 이상만 서비스에 접근 가능하도록 설정. 뿐만 아니라 관리자와 정회원도 구분하여 관리자 기능이 필요할 상황을 대비."]},jwtFilter:{title:"비지니스 로직 실행 전, 요청에 대한 권한 확인 필요",content:"커스텀 JWT 필터를 적용",problem:["일부 제외하고 대부분 기능에서 동일한 보안 정책을 가져가야하는 상황에서 보안이 필요한 모든 기능이 실행되기 전에 비즈니스 로직에서 처리하는 것보다 미리 인가 / 인증을 처리하도록 하고싶음."],solution:["Spring Security에 커스텀 JWT 필터를 적용하여 API 요청이 왔을때, 올바른 권한을 가진 요청인지 아닌지를 판단하여 알맞은 결과를 실행하도록 함."]},whiteList:{title:"일부 API 요청할때 header 안에 토큰을 담기 힘든 경우 존재",content:"해당 api만 url에 토큰을 추가하고 white 리스트로 별도 관리",problem:["일부 API를 요청할때 header 안에 JWT 토큰을 넣기 힘든 경우가 존재하여 url안에 넣는 방식으로 대신 인가 / 인증을 처리하고자 함."],solution:["해당 API url을 white-list로 분류하여 별도의 인가 / 인증 로직을 통해 올바른 권한을 가진 요청인지 확인 후 결과를 실행하도록 함."]},customFilter:{title:"클라이언트 개발을 위해 상황별 상태값 리턴 필요",content:"커스텀 필터를 통해 httpStatus 코드 리턴",problem:["단순하게 권한 체크 우선 이후 로직 처리 패턴으로 하니 존재하지 않는 API요청을 올바르지 않은 권한으로 요청할 경우 404가 아닌 401이 리턴되는 상황이 발생. 클라이언트 개발할 때도 아주 좋지않은 상황이기에 수정하기로 결정."],solution:["커스텀 필터를 통해 권한 에러 뿐만 아니라 여러 에러 상황들(404, 405 등)을 올바르게 리턴함으로서 클라이언트 개발 및 사용자 입장에서도 정확한 정보를 제공하도록 수정함."]},weatherFeature:{title:"모든 클라이언트에게 날씨 정보 제공",content:"기상청 API를 서버에서 호출 및 데이터 파싱을 통해 클라이언트에게 전송",problem:["날씨 정보 제공을 위해 최소 3개의 API를 호출하고 데이터를 파싱하는 과정이 필요. 특히 모바일 환경에서는 연산이 많아질수록 베터리 런타임에도 악영향."],solution:["서버에서 기상청으로부터 데이터를 받고 가공하여 클라이언트는 최소한의 데이터로만 필요한 정보를 사용자에게 제공할 수 있도록 변경."]},iotFeature:{title:"웹에서도 IoT 서비스를 사용할 수 있어야 함",content:"IoT 제어 관련 API를 제공",problem:["안드로이드에서 MQTT를 통해 IoT를 제어 하던 방식 대신 간단하게 많은 리소스를 사용하지 않고 사용하고 싶어함."],solution:["Rest API를 통해 기능을 제공하고 서버에서 해당 값으로 IoT를 제어하는 방향으로 서비스 제공."]},sftp:{title:"파일 제어를 직접 제어하는 위험이 큼",content:"파일 제어 요청만 하고 서버에서 처리하는 방식으로 변경",problem:["기존에는 안드로이드에서 SFTP를 통해 직접 제어하였음. 그에 따라 속도와 파일 제어에 대한 안정성 그리고 추가 기능(썸네일 등)을 위해 방식 변경 필요."],solution:["파일 정보를 DB에 최신화하여 저장하고 이를 통해 클라이언트는 정보를 주고받는 형식으로 변경. 파일 제어는 서버에서 담당."]},fullSearch:{title:"클라우드 서비스 외 방식으로 제어된 파일 정보 최신화를 해야함",content:"주기적으로 클라우드 파일 풀 서치를 통해 파일 정보 최신화",problem:["집 내부 네트워크를 통해 파일을 제어하는 경우 파일 정보가 DB에 저장이 안됨."],solution:["Scheduler를 사용하여 매일 밤 12시 비동기로 클라우드 하드 풀 서치를 통해 파일 정보 전부 최신화 유지."]},thumbnail:{title:"이미지, 비디오 파일들을 바로 인식하기 어려움",content:"썸네일을 이용하여, 해당 파일에 대한 정보 제공",problem:["이미지 및 비디오 파일은 썸네일을 통해 미리 파일에 대한 정보를 확인 할 수 있는 방법이 존재함."],solution:["클라우드 풀 서치할때, 비디오 파일은 추가적으로 썸네일 제작 과정을 통해 해당 기능을 제공하도록 함."]},lowQualityImage:{title:"썸네일 혹은 이미지 미리보기 기능에 너무 많은 데이터 소모",content:"이미지 해상도를 낮게 포맷하여 제공",problem:["이미지 미리보기 기능에 사용되는 이미지의 용량이 너무 커서 과도한 데이터 사용을 요구함.","영상 썸네일 기능에 사용되는 이미지의 용량이 너무 커서 과도한 데이터 사용을 요구함."],solution:["미리보기용 이미지를 전송 전 화질 다운그레이드 후 전송으로 데이터 용량 줄임.","썸네일은 제작 할때 저용량으로 제작하여 데이터 용량 줄임."]},walksAndBulk:{title:"풀 서치 후 DB에 파일 정보 저장하는데 너무 오래 걸림",content:"탐색은 walks, insert는 bulk를 이용",problem:["파일 갯수가 5천개에서 14만개 이후 300만개까지 증가하여서 해당 데이터들을 탐색하고 DB에 단순하게 insert하는데 시간이 너무 오래걸림."],solution:["탐색하는 방식을 walks를 통해 498% 시간 개선을 이뤄냈고, DB에 데이터를 넣는 방식을 bulk으로 변경 후 1,689% 시간 개선을 이뤄냄."]},batch:{title:"영상 갯수가 늘어남에 따라 같이 늘어난 썸네일 만드는 시간을 줄이기",content:"Spring batch의 multi-thread 이용",problem:["영상 파일 갯수가 100개에서 1400개로 증가함에 따라 하루에 한번 풀 서치할때 소요되는 시간이 1시간 추가 됨."],solution:["Spring batch의 multi-thread를 이용하여 3개로 비동기 처리하여 시간을 20분으로 단축시킴."]},CIAndCD:{title:"배포해야할 서비스가 증가함에 따라 자동 CI/CD 필요",content:"Docker와 Jenkins, GitHub를 이용한 자동 CI/CD 구축",problem:["웹, 백엔드(Spring, Django), 로그 웹, 로그 백엔드 등 배포해야할 서비스가 많아짐에 따라 수동 배포보단 자동 배포로 효율성 높일 필요성 증가."],solution:["서버에서 기상청으로부터 데이터를 받고 가공하여 클라이언트는 최소한의 데이터로만 필요한 정보를 사용자에게 제공할 수 있도록 변경."]},restart:{title:"쉽게 서비스 자동 재시작 필요",content:"Docker 컨테이너 옵션을 이용한 자동 재시작",problem:["서버가 수시로 발생한 정전으로 인해 강제 재부팅이 빈번하게 발생. 서버 재부팅 완료 시, 서비스 재시작 필요."],solution:["Docker 컨테이너 옵션 중 restart 옵션을 사용하여 서버 재부팅 시, 컨테이너 재시작하도록 설정."]},container:{title:"서비스를 다른 서버로 언제든 옮길 수 있도록 준비 필요",content:"서비스를 Docker 컨테이너화",problem:["서버가 수시로 발생한 정전으로 인해 내구성에 대한 신뢰성 하락. 서비스를 언제든 옮길 수 있도록 준비."],solution:["서비스 코드를 전부 Docker 컨테이너 화. MongoDB의 데이터는 외부 하드에 백업."]},weatherMaintenance:{title:"기상청 API 변경에 대한 대응 및 추후 변경 가능성에 대해 대비",content:"기상청 API 변경되어 이에 대해 대응 및 기능 서버로 이전하여 중앙화",problem:["기존에 안드로이드에서 제공하는 기상청 API가 주소, API key 만료, 제공된 데이터값 변동에 의해 서비스 중지."],solution:["클라이언트(안드로이드)에서 사용중이던 기상청 API가 API 주소, key, 데이터 타입이 달라지는 상황 발생하여, 날씨 서비스를 서버로 중앙화 하여 유지 보수를 쉽게 변경."]},cloud:{title:"파일 제어를 직접 제어하는 위험이 큼",content:"파일 제어 요청만 하고 서버에서 처리하는 방식으로 변경",problem:["기존에는 안드로이드에서 SFTP를 통해 직접 제어하였음. 그에 따라 속도와 파일 제어에 대한 안정성 그리고 추가 기능(썸네일 등)을 위해 방식 변경 필요."],solution:["파일 정보를 DB에 최신화하여 저장하고 이를 통해 클라이언트는 정보를 주고받는 형식으로 변경. 파일 제어는 서버에서 담당."]},onlyLogic:{title:"IoT 비즈니스 로직에 집중하고자 함",content:"Django 프레임워크를 도입함으로 비즈니스 로직에 좀 더 집중하고자 함",problem:["멀티 프로세싱, 다운되었을때 재실행, DB와의 연동 등을 프레임워크에 전담하고 비즈니스 로직만 개발하여 개발 효율을 올리고자 함."],solution:["Django 프레임워크 및 orm을 사용하여 훨씬 더 안정적으로 서비스를 제공할 수 있을 뿐만 아니라 여러 라이브러리 사용으로 개발 효율도 상승함."]},migration:{title:"기존 Python 스크립트를 이식",content:"같은 Python 기반 프레임워크 Django로 이식",problem:["기존 Python 스크립트를 개발 효율 증가 및 관리 편의성 상승을 위해 프레임워크로 이식을 해야함."],solution:["같은 Python 기반인 Django 프레임워크를 선택하여 이식을 좀 더 수월하게 하도록 함."]},buildLogSystem:{title:"서비스가 늘어남에 따라 로그 확인이 제한적",content:"kafka를 이용해서 로그 시스템 구축",problem:["서비스가 늘어날수록 로그를 확인하는 난이도가 높아짐."],solution:["kafka, mongodb를 이용해서 로그를 수집하고 해당 로그를 웹으로 확인할 수 있도록 하여 외부에서도 로그를 쉽게 수집 및 확인 할 수 있도록 함."]},logDivPart:{title:"하나의 분류로 로그를 전부 모으니 확인 어려움",content:"서비스 별 로그를 분리하여 수집하고 확인 할 때 더 수월",problem:["모든 로그를 한 분류로 보관하니 개별 서비스 확인하는 것이 어려움."],solution:["서비스 별로 로그를 분리, 관리하여 로그를 확인할때 원하는 로그를 더 쉽고 간단하게 확인 할 수 있도록 함."]},block:{title:"서비스를 구현할때 추후 발생할 수 있는 리팩토링을 염두해야함",content:"기능 별 코드를 블럭화 하여 수정 필요시 해당 부분만 수정하도록 함",problem:["수시로 서비스 수정 혹은 추가 요청에 따라 잦은 기능 수정을 수월하게 대응해야함."],solution:["기능을 블럭화 하여 기능을 수정할때 해당 블럭만 수정하면 다른 기능에게 최대한 영향을 미치지 않도록 설계하여 리팩토링을 대비."]},enum:{title:"문자열 혹은 숫자로 하드코딩 된 부분 수정 필요",content:"Enum을 이용하여 데이터를 통합하여 관리하도록 함",problem:["문자열 혹은 숫자로 하드코딩으로 데이터들이 각 파일별 별도로 파편화되어있어서 수정 혹은 관리가 매우 불편함.","Server (example)","Android (example)"],solution:["Enum을 통해 데이터를 일괄적으로 통합하여 관리하는 방법으로 변경. 이후 수정이 필요하더라도 enum 파일만 수정하면 되도록 구축.","Server - BatchEnum.java","Android - RoomInfoEnum.java"]}},iot:{tmp:{title:"",content:"",problem:[""],solution:[""]},origin:{title:"MQTT 서버와 연결이 끊긴 경우 제어 불가능",content:"MQTT 서버와 재연결 시도 되는 동안 버튼 제어 불가능",problem:["MQTT 서버와 연결이 끊긴 경우 연결 재시작 과정이 5초 걸리고 그동안 제어 불가능. 싱글 스레드라서 별도로 분리 불가."],solution:["Ver 1 코드의 에러 설명란."]},connect:{title:"MQTT 서버와 연결 시도를 메인 스레드와 별개로 분리 필요",content:"MQTT 서버와 연결하는 부분을 인터럽트로 이동",problem:["MQTT 서버와 연결 시도를 메인 스레드와 별개로 분리 필요"],solution:["재연결 기능을 인터럽트로 처리하여 메인 스레드로부터 분리. 스위치 제어와는 별개로 작동하도록 함."]},control:{title:"인터럽트 기능이 너무 무거움",content:"인터럽트 기능 자체를 최대한 가볍게 변경",problem:["MQTT 재연결은 인터럽트 기능으로 넣기에 너무 무거운 기능."],solution:["MQTT 재연결은 메인 스레드로 처리하고, 버튼 제어를 인터럽트로 처리하여 가볍게 처리함."]}}};let u=(0,r.ZP)("div")(e=>{let{theme:n}=e;return{transition:"all 0.5s",borderRadius:"0.5rem",padding:"0.2rem","&:hover":{backgroundColor:"dark"===n.palette.mode?"#111":"#f4f5ff"}}});function d(e){let{name:n,codeType:t,part:r,setModalData:d,handleStatus:c}=e,p=(0,l.CG)(e=>e.page.smallMode)?14:16,g=s[r][n].title,m=s[r][n].content,S=s[r][n].problem,f=s[r][n].solution;return(0,i.jsx)(u,{children:(0,i.jsx)("div",{style:{cursor:"pointer"},onClick:()=>{d(g,m,t,r,n,S,f),c()},children:(0,i.jsxs)(o.Z,{marginBottom:"1.5rem",children:[(0,i.jsx)(a.Z,{style:{fontWeight:"bolder"},fontSize:p,children:g}),(0,i.jsx)(a.Z,{fontSize:p,children:m})]})})})}},7925:function(e,n,t){t.d(n,{CG:function(){return o},TL:function(){return r}});var i=t(45007);let r=i.I0,o=i.v9}}]);